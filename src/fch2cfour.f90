! written by jxzou at 20230209: transfer MOs from Gaussian to CFOUR

program main
 use util_wrapper, only: formchk
 implicit none
 integer :: i
 character(len=240) :: fchname
 character(len=61), parameter :: error_warn = &
  ' ERROR in subroutine fch2cfour: wrong command line arguments!'

 i = iargc()
 if(i /= 1) then
  write(6,'(/,A)') error_warn
  write(6,'(A,/)') ' Example: fch2cfour water.fch'
  stop
 end if

 call getarg(1, fchname)
 call require_file_exist(fchname)

 ! if .chk file provided, convert into .fch file automatically
 i = LEN_TRIM(fchname)
 if(fchname(i-3:i) == '.chk') then
  call formchk(fchname)
  fchname = fchname(1:i-3)//'fch'
 end if

 call fch2cfour(fchname)
end program main

subroutine fch2cfour(fchname)
 use fch_content
 implicit none
 integer :: i, nif1, fid
 integer :: n5dmark, n7fmark, n9gmark, n11hmark
 integer :: n6dmark, n10fmark, n15gmark, n21hmark
 integer, allocatable :: d_mark(:), f_mark(:), g_mark(:), h_mark(:)
 character(len=240), intent(in) :: fchname
 real(kind=8), allocatable :: coeff(:,:)
 logical :: uhf, sph, ecp

 i = index(fchname, '.fch', back=.true.)
 if(i == 0) then
  write(6,'(/,A)') "ERROR in subroutine fch2cfour: '.fch' suffix not found in &
                   &file "//TRIM(fchname)
  stop
 end if
 call check_nobasistransform_in_fch(fchname)
 call check_nosymm_in_fch(fchname)

 uhf = .false.
 call check_uhf_in_fch(fchname, uhf) ! determine whether UHF
 call read_fch(fchname, uhf)
 if(LenNCZ > 0) ecp = .true.

 ! check if any spherical functions
 if(ANY(shell_type<-1) .and. ANY(shell_type>1)) then
  write(6,'(A)') 'ERROR in subroutine fch2cfour: mixed spherical harmonic/&
                 &Cartesian functions detected.'
  write(6,'(A)') 'You probably used a basis set like 6-31G(d) in Gaussian. Its&
                & default setting is (6D,7F).'
  write(6,'(A)') "You need to add '5D 7F' or '6D 10F' keywords in Gaussian."
  stop
 else if( ANY(shell_type>1) ) then
  sph = .false.
  ! TODO: support 6D 10F
  write(6,'(/,A)') 'ERROR in subroutine fch2cfour: Cartesian-type basis functio&
                   &ns not supported currently.'
  stop
 else
  sph = .true.
 end if

 call prt_cfour_zmat(natom, elem, coor, charge, mult, uhf, ecp)
 deallocate(coor)

 call prt_cfour_genbas()

! Secondly, permute MO coefficients and generate the orbital file
 if(uhf) then ! UHF
  allocate(coeff(nbf,2*nif))
  coeff(:,1:nif) = alpha_coeff
  coeff(:,nif+1:2*nif) = beta_coeff
  deallocate(alpha_coeff, beta_coeff)
  nif1 = 2*nif
 else         ! R(O) HF
  allocate(coeff(nbf,nif))
  coeff(:,:) = alpha_coeff
  deallocate(alpha_coeff)
  nif1 = nif
 end if

! ! record the indices of d, f, g and h functions
! allocate(d_mark(ncontr), f_mark(ncontr), g_mark(ncontr), h_mark(ncontr))
!
! if(sph) then
!  call read_mark_from_shltyp_sph(ncontr, shell_type, n5dmark, n7fmark, n9gmark, &
!                                 n11hmark, d_mark, f_mark, g_mark, h_mark)
!  ! adjust the order of 5d, 7f, etc. functions
!  call fch2inporb_permute_sph(n5dmark, n7fmark, n9gmark, n11hmark, k, d_mark, &
!                              f_mark, g_mark, h_mark, nbf, nif1, coeff)
! else
!  call read_mark_from_shltyp_cart(ncontr, shell_type, n6dmark, n10fmark, n15gmark,&
!                                  n21hmark, d_mark, f_mark, g_mark, h_mark)
!  ! adjust the order of 6d, 10f, etc. functions
!  call fch2qchem_permute_cart(n6dmark, n10fmark, n15gmark, n21hmark, k, d_mark,&
!                              f_mark, g_mark, h_mark, nbf, nif1, coeff)
! end if
!
! deallocate(d_mark, f_mark, g_mark, h_mark, shell_type)
! allocate(alpha_coeff(nbf,nif))
! alpha_coeff = coeff(:,1:nif)
! if(uhf) then
!  allocate(beta_coeff(nbf,nif))
!  beta_coeff = coeff(:,nif+1:2*nif)
! end if
! deallocate(coeff)

 ! print CFOUR orbital file OLDMOS
 call prt_cfour_oldmos(nbf, nif, coeff)
end subroutine fch2cfour

! print/create/write the CFOUR input file ZMAT
subroutine prt_cfour_zmat(natom, elem, coor, charge, mult, uhf, ecp)
 implicit none
 integer :: i, fid
 integer, intent(in) :: natom, charge, mult
 real(kind=8), intent(in) :: coor(3,natom)
 character(len=2), intent(in) :: elem(natom)
 logical, intent(in) :: uhf, ecp

 open(newunit=fid,file='ZMAT',status='replace')
 write(fid,'(A)') 'Generated by fch2cfour of MOKIT'
 do i = 1, natom, 1
  write(fid,'(A2,1X,3(1X,F18.8))') elem(i), coor(:,i)
 end do ! for i

 write(fid,'(/,A)',advance='no') '*CFOUR(CALC=SCF,REF='
 if(uhf) then
  write(fid,'(A)',advance='no') 'U'
 else
  if(mult == 1) then
   write(fid,'(A)',advance='no') 'R'
  else
   write(fid,'(A)',advance='no') 'RO'
  end if
 end if
 write(fid,'(2(A,I0),A)') 'HF,CHARGE=', charge, ',MULTI=', mult, &
                          ',BASIS=STO-3G,SYM=OFF'
 if(ecp) write(fid,'(A)',advance='no') 'ECP=ON,'
 write(fid,'(A,/)') 'COORD=CARTESIAN)'
 close(fid)
end subroutine prt_cfour_zmat

! print basis set and ECP(if any) data into GENBAS and ECPDATA
subroutine prt_cfour_genbas(ecp)
 use fch_content
 implicit none
 integer :: i, j, k, m, n, n1, n2, fid
 character(len=1) :: str = ' '
 character(len=2) :: str2 = '  '
 logical :: has_sp
 logical, intent(in) :: ecp

 open(newunit=fid,file='GENBAS',status='replace')
 write(fid,'(A)') elem(1)//':GEN'
 write(fid,'(A,/)') 'generated by fch2cfour of MOKIT'

 k = 0
 do i = 1, ncontr, 1
  m = shell2atom_map(i)
  if(m > 1) then
   if(shell2atom_map(i-1) == m-1) then
    if(elem(m) == elem(m-1)) cycle
    write(fid,'(/,A,1X,A)') elem(m)//':GEN'
    write(fid,'(A,/)') 'generated by fch2cfour of MOKIT'
   end if
  end if

  m = shell_type(i); n = prim_per_shell(i)
  if(m < -1) m = -m
  if(m == -1) then
   str2 = 'SP'
  else
   str2 = am_type(m)//' '
  end if
  write(fid,'(A2,1X,I2,3X,A)') str2, n, '1.00'

  has_sp = .false.
  if(allocated(contr_coeff_sp)) then
   if(ANY(contr_coeff_sp(k+1:k+n) > 1d-6)) has_sp = .true.
  end if

  if(has_sp) then
   do j = k+1, k+n, 1
    write(fid,'(3(2X,ES15.8))') prim_exp(j), contr_coeff(j), contr_coeff_sp(j)
   end do ! for j
  else ! no SP in this paragraph
   do j = k+1, k+n, 1
    write(fid,'(2(2X,ES15.8))') prim_exp(j), contr_coeff(j)
   end do ! for j
  end if

  k = k + n
 end do ! for i

 close(fid)
 deallocate(ielem, prim_per_shell, prim_exp, contr_coeff)
 if(allocated(contr_coeff_sp)) deallocate(contr_coeff_sp)
 deallocate(shell2atom_map)

 if(.not. ecp) return
 open(newunit=fid,file='ECPDATA',status='replace')

 do i = 1, natom, 1
  if(LPSkip(i) /= 0) then
   cycle
  else
   write(fid,'(A)') elem(i)//'     0'
   write(fid,'(A,2X,I2,2X,I3)') elem(i)//'-ECP', LMax(i), INT(RNFroz(i))
   str = am_type1(LMax(i))

   do j = 1, 10, 1
    n1 = KFirst(i,j); n2 = KLast(i,j)
    if(n1 == 0) exit
    if(j == 1) then
     write(fid,'(A)') str//' potential'
    else
     write(fid,'(A)') am_type1(j-2)//'-'//str//' potential'
    end if
    write(fid,'(I2)') n2-n1+1
    do n = n1, n2, 1
     write(fid,'(I0,2(3X,ES15.8))') NLP(n), ZLP(n), CLP(n)
    end do ! for n
   end do ! for j

   write(fid,'(A)') '****'
  end if
 end do ! for i

 close(fid)
 deallocate(KFirst, KLast, Lmax, LPSkip, NLP, RNFroz, CLP, CLP2, ZLP, elem)
end subroutine prt_cfour_genbas

! print CFOUR orbital file OLDMOS
subroutine prt_cfour_oldmos(nbf, nif, coeff)
 implicit none
 integer :: i, j, k, nb, fid
 integer, intent(in) :: nbf, nif
 real(kind=8), intent(in) :: coeff(nbf,nif)
 character(len=9) :: str

 open(newunit=fid,file='OLDMOS',status='replace')

 nb = nif/4
 do i = 1, nb, 1
  write(fid,'(4E30.20)') ((coeff(j,k),k=4*i-3,4*i,1),j=1,nbf,1)
 end do ! for i

 i = nif - 4*nb
 if(i > 0) then
  str = ' '
  write(str,'(A1,I1,A7)') '(',i,'E30.20)'
  write(unit=fid,fmt=str) ((coeff(j,k),k=nif-i+1,nif,1),j=1,nbf,1)
 end if

 close(fid)
end subroutine prt_cfour_oldmos

subroutine fch2qchem_permute_cart(n6dmark, n10fmark, n15gmark, n21hmark, k, d_mark, &
                                  f_mark, g_mark, h_mark, nbf, nif, coeff2)
 implicit none
 integer :: i
 integer, intent(in) :: n6dmark, n10fmark, n15gmark, n21hmark, k, nbf, nif
 integer, intent(in) :: d_mark(k), f_mark(k), g_mark(k), h_mark(k)
 real(kind=8), intent(inout) :: coeff2(nbf,nif)

 if(n6dmark==0 .and. n10fmark==0 .and. n15gmark==0 .and. n21hmark==0) return

 do i = 1, n6dmark, 1
  call fch2qchem_permute_6d(nif, coeff2(d_mark(i):d_mark(i)+5,:))
 end do
 do i = 1, n10fmark, 1
  call fch2qchem_permute_10f(nif, coeff2(f_mark(i):f_mark(i)+9,:))
 end do
 do i = 1, n15gmark, 1
  call fch2qchem_permute_15g(nif, coeff2(g_mark(i):g_mark(i)+14,:))
 end do
 do i = 1, n21hmark, 1
  call fch2qchem_permute_21h(nif, coeff2(h_mark(i):h_mark(i)+20,:))
 end do

end subroutine fch2qchem_permute_cart

subroutine fch2qchem_permute_6d(nif,coeff)
 implicit none
 integer :: i
 integer, parameter :: order(6) = [1, 4, 2, 5, 6, 3]
 integer, intent(in) :: nif
 real(kind=8), intent(inout) :: coeff(6,nif)
 real(kind=8), allocatable :: coeff2(:,:)
! From: the order of Cartesian d functions in Gaussian
! To: the order of Cartesian d functions in QChem
! 1  2  3  4  5  6
! XX,YY,ZZ,XY,XZ,YZ
! XX,XY,YY,XZ,YZ,ZZ

 allocate(coeff2(6,nif), source=coeff)
 forall(i = 1:6) coeff(i,:) = coeff2(order(i),:)
 deallocate(coeff2)
end subroutine fch2qchem_permute_6d

subroutine fch2qchem_permute_10f(nif,coeff)
 implicit none
 integer :: i
 integer, parameter :: order(10) = [1, 5, 4, 2, 6, 10, 9, 7, 8, 3]
 integer, intent(in) :: nif
 real(kind=8), intent(inout) :: coeff(10,nif)
 real(kind=8), allocatable :: coeff2(:,:)
! From: the order of Cartesian f functions in Gaussian
! To: the order of Cartesian f functions in Qchem
! 1   2   3   4   5   6   7   8   9   10
! XXX,YYY,ZZZ,XYY,XXY,XXZ,XZZ,YZZ,YYZ,XYZ
! XXX,XXY,XYY,YYY,XXZ,XYZ,YYZ,XZZ,YZZ,ZZZ

 allocate(coeff2(10,nif), source=coeff)
 forall(i = 1:10) coeff(i,:) = coeff2(order(i),:)
 deallocate(coeff2)
end subroutine fch2qchem_permute_10f

subroutine fch2qchem_permute_15g(nif,coeff)
 implicit none
 integer :: i
 integer, intent(in) :: nif
 integer, parameter :: order(15) = [15, 14, 12, 9, 5, 13, 11, 8, 4, 10, 7, 3, 6, 2, 1]
 real(kind=8), intent(inout) :: coeff(15,nif)
 real(kind=8), allocatable :: coeff2(:,:)
! From: the order of Cartesian g functions in Gaussian
! To: the order of Cartesian g functions in QChem
! 1    2    3    4    5    6    7    8    9    10   11   12   13   14   15
! ZZZZ,YZZZ,YYZZ,YYYZ,YYYY,XZZZ,XYZZ,XYYZ,XYYY,XXZZ,XXYZ,XXYY,XXXZ,XXXY,XXXX
! xxxx,xxxy,xxyy,xyyy,yyyy,xxxz,xxyz,xyyz,yyyz,xxzz,xyzz,yyzz,xzzz,yzzz,zzzz

 allocate(coeff2(15,nif), source=coeff)
 forall(i = 1:15) coeff(i,:) = coeff2(order(i),:)
 deallocate(coeff2)
end subroutine fch2qchem_permute_15g

subroutine fch2qchem_permute_21h(nif,coeff)
 implicit none
 integer :: i
 integer, intent(in) :: nif
 integer, parameter :: order(21) = [21, 20, 18, 15, 11, 6, 19, 17, 14, 10, 5, &
                                    16, 13, 9, 4, 12, 8, 3, 7, 2, 1]
 real(kind=8), intent(inout) :: coeff(21,nif)
 real(kind=8), allocatable :: coeff2(:,:)
! From: the order of Cartesian h functions in Gaussian
! To: the order of Cartesian h functions in QChem
! 1     2     3     4     5     6     7     8     9     10    11    12    13    14    15    16    17    18    19    20    21
! ZZZZZ,YZZZZ,YYZZZ,YYYZZ,YYYYZ,YYYYY,XZZZZ,XYZZZ,XYYZZ,XYYYZ,XYYYY,XXZZZ,XXYZZ,XXYYZ,XXYYY,XXXZZ,XXXYZ,XXXYY,XXXXZ,XXXXY,XXXXX
! xxxxx,xxxxy,xxxyy,xxyyy,xyyyy,yyyyy,xxxxz,xxxyz,xxyyz,xyyyz,yyyyz,xxxzz,xxyzz,xyyzz,yyyzz,xxzzz,xyzzz,yyzzz,xzzzz,yzzzz,zzzzz

 allocate(coeff2(21,nif), source=coeff)
 forall(i = 1:21) coeff(i,:) = coeff2(order(i),:)
 deallocate(coeff2)
end subroutine fch2qchem_permute_21h

