! written by jxzou at 20210115: generate Gaussian .gjf from ORCA .mkl file
! TODO: un-normalize the contracted coefficients of each basis function (this
!       does affect the calculation)

! Note: this utility can only be applied to all-electron basis set, since the
!  .mkl file does not contain ECP information

! The 'Shell types' array in Gaussian .fch file:
!
!   Spherical     |   
! -5,-4,-3,-2,-1, 0, 1
!  H  G  F  D  L  S  P
!
! 'L' is 'SP' in Pople-type basis sets

program main
 implicit none
 integer :: i, k, narg, irel
 character(len=240) :: mklname, gjfname
 character(len=240), allocatable :: str_arg(:)
 logical :: pcnuc

 narg = iargc()
 if(narg<1 .or. narg>3) then
  write(6,'(/,A)') ' ERROR in program mkl2gjf: wrong command line argument!'
  write(6,'(A)')   ' Example 1: mkl2gjf a.mkl'
  write(6,'(A)')   ' Example 2: mkl2gjf a.mkl b.gjf'
  write(6,'(A)')   ' Example 3: mkl2gjf a.mkl -dkh2'
  write(6,'(A)')   ' Example 4: mkl2gjf a.mkl -dkh2 -gfnuc'
  write(6,'(A)')   ' Example 5: mkl2gjf a.mkl -dkh4'
  write(6,'(A)')   ' Example 6: mkl2gjf a.mkl -dkhso'
  write(6,'(A)')   ' Example 7: mkl2gjf a.mkl -sfx2c'
  write(6,'(A,/)') ' Example 8: mkl2gjf a.mkl b.gjf -dkh2'
  stop
 end if

 allocate(str_arg(narg))
 do i = 1, narg, 1
  call getarg(i, str_arg(i))
 end do ! for i

 mklname = str_arg(1)
 call require_file_exist(mklname)
 call find_specified_suffix(mklname, '.mkl', i)
 gjfname = mklname(1:i-1)//'.gjf'
 k = 2; irel = -1; pcnuc = .true.

 if(narg > 1) then
  i = LEN_TRIM(str_arg(2))
  if(str_arg(2)(i-3:i) == '.gjf') then
   gjfname = str_arg(2)
   k = 3
  end if
  if(k <= narg) then
   select case(TRIM(str_arg(k)))
   case('-sfx2c')
    irel = -3
   case('-resc')
    irel = -2
   case('-dkh0')
    irel = 0
   case('-dkh','-dkh2')
    irel = 2
   case('-dkh4','-dkhso')
    irel = 4
   case('-pcnuc') ! do nothing
   case('-gfnuc')
    pcnuc = .false.
   case default
    write(6,'(/,A)') 'ERROR in subroutine mkl2gjf: wrong command line argument!'
    write(6,'(A)')   'Example: mkl2gjf a.mkl -dkh2'
    stop
   end select
  end if
 end if

 deallocate(str_arg)
 call mkl2gjf(mklname, gjfname, irel, pcnuc)
end program main

! generate Gaussian .gjf from ORCA .mkl file
subroutine mkl2gjf(mklname, gjfname, irel, pcnuc)
 use mkl_content
 implicit none
 integer :: i, j, k, nc, nline, ncol, fid
 integer :: ndmark, nfmark, ngmark, nhmark, nimark
 integer, allocatable :: d_mark(:), f_mark(:), g_mark(:), h_mark(:), i_mark(:)
 integer, intent(in) :: irel
 real(kind=8), allocatable :: coeff(:,:)
 character(len=240), intent(in) :: mklname, gjfname
 logical :: uhf
 logical, intent(in) :: pcnuc

 call find_specified_suffix(gjfname, '.gjf', i)
 open(newunit=fid,file=TRIM(gjfname),status='replace')
 write(fid,'(A)') '%chk='//gjfname(1:i-1)//'.chk'
 write(fid,'(A)') '%nprocshared=4'
 write(fid,'(A)') '%mem=4GB'

 call check_uhf_in_mkl(mklname, uhf)
 call read_mkl(mklname, uhf, .true.)
 deallocate(shl2atm)

 if(ANY(nuc > 18)) then
  write(6,'(/,A)') "Warning in subroutine mkl2gjf: element(s)>'Ar' detected."
  write(6,'(A)') 'NOTE: the .mkl file does not contain ECP/PP information. If y&
                 &ou use ECP/PP'
  write(6,'(A)') '(in ORCA .inp file), there would be no ECP in the generated .&
                 &gjf file. You'
  write(6,'(A)') "should manually add ECP data into .gjf, and change 'gen' into&
                 & 'genecp'. If"
  write(6,'(A,/)') 'you are using an all-electron basis set, there is no proble&
                   &m.'
 end if
 deallocate(nuc)

 write(fid,'(A)',advance='no') '#p'
 if(uhf) then
  write(fid,'(A)',advance='no') ' UHF/'
 else
  if(mult /= 1) then
   write(fid,'(A)',advance='no') ' ROHF/'
  else
   write(fid,'(A)',advance='no') ' RHF/'
  end if
 end if
 write(fid,'(A)',advance='no') 'gen int'
 ! we do not know using gen or genecp, since ECP/PP data is not included in .mkl

 select case(irel)
 case(-3)
  write(fid,'(A)',advance='no') '(nobasistransform,X2C)'
 case(-2)
  write(fid,'(A)',advance='no') '(nobasistransform,RESC)'
 case(-1)
  write(fid,'(A)',advance='no') '=nobasistransform'
 case(0)
  write(fid,'(A)',advance='no') '(nobasistransform,DKH0)'
 case(2)
  write(fid,'(A)',advance='no') '(nobasistransform,DKH2)'
 case(4)
  write(fid,'(A)',advance='no') '(nobasistransform,DKHSO)'
 end select
 if(irel/=-1 .and. pcnuc) write(fid,'(A)',advance='no') ' iop(3/93=1)'
 write(fid,'(A)') ' nosymm guess=cards'

 write(fid,'(/,A,/)') 'generated by mkl2gjf in MOKIT'
 write(fid,'(I0,1X,I0)') charge, mult

 ! print elements and Cartesian coordinates
 do i = 1, natom, 1
  write(fid,'(A2,3(1X,F18.8))') elem(i), coor(1:3,i)
 end do ! for i
 deallocate(elem, coor)
 write(fid,'(/)',advance='no')

 ! print basis set
 do i = 1, natom, 1
  write(fid,'(I0,A2)') i, ' 0'
  nc = all_pg(i)%nc

  do j = 1, nc, 1
   nline = all_pg(i)%prim_gau(j)%nline
   ncol = all_pg(i)%prim_gau(j)%ncol
   write(fid,'(A,2X,I0,A)') all_pg(i)%prim_gau(j)%stype, nline, '  1.00'

   do k = 1, nline, 1
    select case(ncol)
    case(2)
     write(fid,'(2ES20.10)') all_pg(i)%prim_gau(j)%coeff(k,1:2)
    case(3)
     write(fid,'(3ES20.10)') all_pg(i)%prim_gau(j)%coeff(k,1:3)
    case default
     write(6,'(/,A)') 'ERROR in subroutine mkl2gjf: ncol out of range.'
     write(6,'(A,I0)') 'ncol=', ncol
     stop
    end select
   end do ! for k
  end do ! for j

  write(fid,'(A)') '****'
 end do ! for i
 deallocate(all_pg)
 ! print basis set done

 ! update MO coefficients
 if(uhf) then ! UHF
  k = 2*nif
  allocate(coeff(nbf,k))
  coeff(:,1:nif) = alpha_coeff
  coeff(:,nif+1:) = beta_coeff
 else         ! R(O)HF
  k = nif
  allocate(coeff(nbf,k), source=alpha_coeff)
 end if

 ! find F+3, G+3 and H+3 functions, multiply them by -1
 allocate(d_mark(ncontr), f_mark(ncontr), g_mark(ncontr), h_mark(ncontr), &
          i_mark(ncontr))
 call read_mark_from_shltyp_sph(ncontr, shell_type, ndmark, nfmark, ngmark, &
                      nhmark, nimark, d_mark, f_mark, g_mark, h_mark, i_mark)
 deallocate(d_mark, shell_type)
 call update_mo_using_mark_orca(nbf, k, nfmark, ngmark, nhmark, nimark, ncontr,&
                                f_mark, g_mark, h_mark, i_mark, coeff)
 deallocate(f_mark, g_mark, h_mark, i_mark)

 if(uhf) then ! UHF
  alpha_coeff = coeff(:,1:nif)
  beta_coeff = coeff(:,nif+1:)
 else         ! R(O)HF
  alpha_coeff = coeff
 end if
 deallocate(coeff)
 ! update MO coefficients done

 write(fid,'(/,A)') '(5E18.10)'
 do i = 1, nif, 1
  write(fid,'(I5,A,E15.8)') i, ' Alpha MO OE=', ev_a(i)
  write(fid,'((5E18.10))') (alpha_coeff(j,i),j=1,nbf)
 end do ! for i
 deallocate(alpha_coeff, ev_a)

 if(uhf) then
  write(fid,'(/)',advance='no')
  do i = 1, nif, 1
   write(fid,'(I5,A,E15.8)') i, ' Beta MO OE=', ev_b(i)
   write(fid,'((5E18.10))') (beta_coeff(j,i),j=1,nbf)
  end do ! for i
  deallocate(beta_coeff, ev_b)
 end if

 write(fid,'(/)')
 close(fid)
end subroutine mkl2gjf

