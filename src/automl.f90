! written by jxzou at 20240322
! TODO: support LSF bsub

module ml_info
 implicit none
 integer :: mem = 4000 ! in MB
 integer :: nproc = 24
 integer :: ntraj = 0
 integer, parameter :: max_njobs = 200     ! 200 nodes
 integer, parameter :: n_mlp = 4           ! 4 MLPs
 integer, parameter :: queue_type = 1      ! SLURM sbatch
 integer, parameter :: max_num_epochs = 25 ! 40 epochs
 integer, parameter :: max_it = 1          ! max No. iterations
 integer, parameter :: gfnff_md_time = 2   ! 5.0 ps
 real(kind=8), allocatable :: t_range(:)   ! size ntraj
 real(kind=8), parameter :: t_low=273.15d0, t_high=423.15d0, t_intv=50d0 ! K
 ! the lowest/highest temperature, the temperature interval
 real(kind=8), parameter :: mlp_e_diff = 0.04336408d0 ! eV, chemical accuracy
 real(kind=8), parameter :: mlp_f_diff = 0.10284417d0 ! eV/A, 0.002 Hart/Bohr
 ! the threshold of difference between two MLP-predicted energy for a snapshot
 ! the threshold of difference between two MLP-predicted forces for a snapshot
 logical :: use_gpu = .false. ! use CPU/GPU
end module ml_info

program main
 use ml_info
 implicit none
 integer :: i, charge, mult, nframe
 character(len=24) :: data_string
 character(len=240) :: gjfname, proname, proname1, inpname, gfnff_xyz, md_xyz,&
  eval_xyz

 i = iargc()
 if(i /= 1) then
  write(6,'(/,A)') 'ERROR in program automl: wrong command line argument!'
  write(6,'(A,/)') 'Example: automl h2o.gjf'
  stop
 end if

 gjfname = ' '
 call getarg(1, gjfname)
 call gjf2coord(gjfname)

 call find_specified_suffix(gjfname, '.gjf', i)
 proname = gjfname(1:i-1)
 inpname = gjfname(1:i-1)//'.inp'
 gfnff_xyz = gjfname(1:i-1)//'.xyz'
 md_xyz = gjfname(1:i-1)//'_md.xyz'
 eval_xyz = gjfname(1:i-1)//'_eval.xyz'
 call read_charge_and_mult_from_gjf(gjfname, charge, mult)
 call read_mem_and_nproc_from_gjf(gjfname, mem, nproc)

 call run_multi_gfn_ff_md(proname, charge, mult, nproc)
 write(6,'(A,I0)') 'No. trajectories: ', ntraj

 do i = 0, max_it, 1
  write(6,'(A,I0)') 'No. iter: ', i
  call split_pbc_xyz_into_cp2k_inp(gfnff_xyz, charge, mult)
  call read_nframe_from_xyz(gfnff_xyz, nframe)
  if(i == 0) write(6,'(A,I0)') 'No. frames generated by GFN-FF MD: ', nframe

  call gen_batch_script_cp2k(proname)
  call submit_cp2k_jobs(proname, nframe)
  call find_cp2k_failed_and_resubmit(proname, nframe)
  call transfer_force_stress2xyz(proname, nframe, .true.)
  call extract_final_frame_in_xyz(gfnff_xyz, md_xyz)
  call merge_two_train_xyz(proname)

  call gen_batch_script_mace_train(proname, (i>0))
  if(i == 1) then
   write(6,'(A)') 'Tested OK.'
   stop
  end if
  call submit_mace_jobs(proname, n_mlp)

  call gen_batch_script_mace_md(proname, (i>5))
  proname1 = TRIM(proname)//'_md'
  call submit_mace_jobs(proname1, ntraj)
  stop
  proname1 = TRIM(proname)//'_eval'
  call merge_xyz(proname1, ntraj, .false.)
  call read_nframe_from_xyz(eval_xyz, nframe)
  write(6,'(A,I0)') 'No. frames generated by MLMD: ', nframe

  call gen_batch_script_mace_eval(proname)
  call submit_mace_jobs(proname, n_mlp)

  call find_e_f_diff(proname, nframe)
 end do ! for i

 deallocate(t_range)
 call fdate(data_string)
 write(6,'(/,A)') 'Normal termination of AutoML at '//TRIM(data_string)
end program main

subroutine run_multi_gfn_ff_md(proname0, charge, mult, nproc0)
 use ml_info, only: gfnff_md_time, t_low, t_high, t_intv, ntraj, t_range
 implicit none
 integer :: i, j, nproc, RENAME
 integer, intent(in) :: charge, mult, nproc0
 real(kind=8) :: tmp, lat_vec(3,3)
 real(kind=8), parameter :: thres = 1d-2
 character(len=240) :: inpname, coord0, coord, proname, xyzname, trjname
 character(len=240), intent(in) :: proname0

 ntraj = FLOOR((t_high - t_low)/t_intv)
 tmp = DBLE(ntraj)*t_intv + t_low

 if(DABS(tmp - t_high) < thres) then
  ntraj = ntraj + 1
 else if(tmp < t_high) then
  ntraj = ntraj + 2
 end if
 nproc = nproc0/ntraj ! the number of processors for each trajectory

 allocate(t_range(ntraj), source=0d0)
 t_range(1) = t_low
 t_range(ntraj) = t_high

 do i = 2, ntraj-1, 1
  t_range(i) = t_low + t_intv*DBLE(i-1)
 end do ! for i
 coord0 = TRIM(proname0)//'.coord'
 call read_lat_vec_from_coord(coord0, lat_vec)

 ! before the GFN-FF MD starts, all proname_*.xyz need to be deleted (if any
 ! such file exists), since proname_*.coord files are to be used here, rather
 ! than .xyz files.
 do i = 1, ntraj, 1
  write(xyzname,'(A,I0,A)') TRIM(proname0)//'_', i, '.xyz'
  call delete_file(TRIM(xyzname))
 end do ! for i

!$omp parallel do schedule(dynamic) default(private) &
!$omp shared(ntraj, proname0, coord0, t_range, charge, mult, nproc, lat_vec)
 do i = 1, ntraj, 1
!$omp critical
  write(proname,'(A,I0)') TRIM(proname0)//'_', i
  coord = TRIM(proname)//'.coord'
  call sys_copy_file(coord0, coord, .false.)
!$omp end critical
  inpname = TRIM(proname)//'.inp'
  trjname = TRIM(proname)//'.xtb.trj'
  call prt_gfn_ff_md_inp(inpname, gfnff_md_time, t_range(i))
  call submit_xtb_job(proname, charge, mult, -1, nproc, 3, .true.)
  call delete_file(coord)
  call add_lat_vec_into_xyz(trjname, lat_vec)
 end do ! for i
!$omp end parallel do

 call delete_file(coord0)

 do i = 1, ntraj, 1
  write(proname,'(A,I0)') TRIM(proname0)//'_', i
  trjname = TRIM(proname)//'.xtb.trj'
  xyzname = TRIM(proname)//'.xyz'
  j = RENAME(TRIM(trjname), TRIM(xyzname))

  do j = 1, gfnff_md_time, 1
   write(xyzname,'(A,I0)') TRIM(proname)//'.scoord.', j
   call delete_file(TRIM(xyzname))
  end do ! for j
 end do ! for i

 ! Merge these .xyz files. The 1st frame in each .xyz file is identical, skip
 ! them from the 2nd file.
 call merge_xyz(proname0, ntraj, .true.)
end subroutine run_multi_gfn_ff_md

subroutine prt_gfn_ff_md_inp(inpname, md_time, temp)
 implicit none
 integer :: fid
 integer, intent(in) :: md_time
 real(kind=8), intent(in) :: temp ! thermostat temperature (K)
 character(len=240), intent(in) :: inpname

 open(newunit=fid,file=TRIM(inpname),status='replace')
 write(fid,'(A)') '$md'
 write(fid,'(A,F7.2,A)') ' temp=', temp, ' # K'
 write(fid,'(A,I0,A)') ' time=',md_time,'.0 # ps'
 write(fid,'(A)') ' step=1.0 # fs'
 write(fid,'(A)') ' dump=25'
 write(fid,'(A)') ' hmass=4.0'
 write(fid,'(A)') ' shake=1'
 write(fid,'(A)') ' nvt=true'
 write(fid,'(A)') ' sccacc=2.0'
 write(fid,'(A)') '$end'
 close(fid)
end subroutine prt_gfn_ff_md_inp

! Submit a batch of xTB jobs using OpenMP parallelism.
! These jobs must share the same charge, mult, gfn and job_type.
subroutine submit_xtb_jobs_omp(proname, nfile, charge, mult, gfn, job_type, &
                               del_tmp)
 implicit none
 integer :: i
 integer, intent(in) :: nfile, charge, mult, gfn, job_type
 ! job_type: -1/0/1/2/3 for opt/sp/force/freq/md
 character(len=240) :: proname1 = ' '
 character(len=240), intent(in) :: proname
 logical, intent(in) :: del_tmp

 write(6,'(/,2(A,I0),A)') 'Submitting GFN', gfn, '-xTB jobs: nfile=', nfile, &
                          ', proname='//TRIM(proname)

!$omp parallel do schedule(dynamic) default(private) &
!$omp shared(proname, nfile, charge, mult, gfn, job_type, del_tmp)
 do i = 1, nfile, 1
!$omp critical
  write(proname1,'(A,I0)') TRIM(proname)//'_',i
!$omp end critical
  call submit_xtb_job(proname1, charge, mult, gfn, 1, job_type, del_tmp)
 end do ! for i
!$omp end parallel do

 write(6,'(A)') 'xTB jobs done.'
end subroutine submit_xtb_jobs_omp

! Submit an xTB job
! Note: if you want to submit a batch of xTB jobs, you can set nproc to be 1
!  here and call subroutine submit_xtb_jobs_omp
subroutine submit_xtb_job(proname, charge, mult, gfn, nproc, job_type, del_tmp)
 implicit none
 integer :: i, fid, system
 integer, intent(in) :: charge, mult, gfn, nproc, job_type
 ! gfn: -1/0/1/2 for GFN-FF/GFN0-xTB/GFN1-xTB/GFN2-xTB
 ! nproc: number of parallel processes
 ! job_type: -1/0/1/2/3 for opt/sp/force/freq/md
 character(len=240) :: shname, inpname, xyzname, chgname, wboname, logname, &
  res_name, molname, outname, gradname, okname, coord, fnconv1, fnconv2
 character(len=240), intent(in) :: proname
 logical, intent(in) :: del_tmp
 ! del_tmp: whether to delete useless files after the job finished
 logical :: alive

 shname  = TRIM(proname)//'.sh'
 inpname = TRIM(proname)//'.inp'
 outname = TRIM(proname)//'.out'
 xyzname = TRIM(proname)//'.xyz'
 coord   = TRIM(proname)//'.coord'
 gradname= TRIM(proname)//'.gradient'

 open(newunit=fid,file=TRIM(shname),status='replace')
 write(fid,'(A)') '#!/bin/bash'
 write(fid,'(A)') '# auto-generated file to submit an xTB job'
 write(fid,'(A)') 'unset KMP_STACKSIZE'
 write(fid,'(A,I0)') 'export MKL_NUM_THREADS=', nproc
 write(fid,'(A,I0,A)') 'export OMP_NUM_THREADS=', nproc, ',1'
 write(fid,'(A)') 'export OMP_STACKSIZE=2G'
 write(fid,'(A)') 'ulimit -s unlimited'

 ! if .xyz file does not exist, use .coord file
 inquire(file=TRIM(xyzname),exist=alive)
 if(.not. alive) xyzname = coord
 write(fid,'(/,A)',advance='no') 'xtb '//TRIM(xyzname)

 select case(job_type)
 case(-1) ! opt
  write(fid,'(A)',advance='no') ' -o tight --cycles 2000'
 case(0) ! sp
  ! do nothing
 case(1) ! force
  write(fid,'(A)',advance='no') ' --grad'
 case(2) ! freq
  write(fid,'(A)',advance='no') ' --hess --grad'
 case(3) ! md
  write(fid,'(A)',advance='no') ' --md'
 case default
  write(6,'(/,A,I0)') 'ERROR in subroutine submit_xtb_job: invalid job_type=',&
                      job_type
  write(6,'(A)') 'Only -1/0/1/2 are allowed.'
  stop
 end select

 write(fid,'(A)',advance='no') ' --namespace '//TRIM(proname)
 inquire(file=TRIM(inpname), exist=alive)
 if(alive) write(fid,'(A)',advance='no') ' -I '//TRIM(inpname)
 if(gfn == -1) then
  write(fid,'(A)',advance='no') ' --gfnff'
 else
  write(fid,'(A,I0)',advance='no') ' --gfn ', gfn
 end if
 write(fid,'(3(A,I0),A)') ' -c ',charge,' -u ',mult-1,' >'//TRIM(outname)//" 2>&1"
 close(fid)

 i = system('/bin/bash '//TRIM(shname))
 if(i /= 0) then
  write(6,'(/,A)') 'Warning from subroutine submit_xtb_job: an xTB job failed.'
  write(6,'(A)') 'Filename='//TRIM(proname)
  write(6,'(A)') 'Anyway, the program will continue.'
 end if

 if(del_tmp) then
  if(gfn == -1) then
   chgname = TRIM(proname)//'.gfnff_charges'
   molname = TRIM(proname)//'.gfnff_topo'
   res_name= TRIM(proname)//'.mdrestart'
   okname  = TRIM(proname)//'.xtbmdok'
  else
   chgname = TRIM(proname)//'.charges'
   molname = TRIM(proname)//'.xtbtopo.mol'
   res_name= TRIM(proname)//'.xtbrestart'
   okname  = '.'//TRIM(proname)//'.xtboptok'
  end if
  wboname = TRIM(proname)//'.wbo'
  logname = TRIM(proname)//'.xtbopt.log'
  fnconv1 = TRIM(proname)//'.NOT_CONVERGED'
  fnconv2 = TRIM(proname)//'.sccnotconverged'
  ! if the job is accomplished successfully, delete all useless files; if
  ! it fails, keep some files for analysis
  call delete_files(7,[chgname,wboname,logname,res_name,molname,gradname,inpname])

  if(i == 0) then
   call delete_files(3, [shname, outname, okname])
  else
   call delete_files(2, [fnconv1, fnconv2])
  end if

  if(job_type == 2) then
   chgname = TRIM(proname)//'.vibspectrum'
   wboname = TRIM(proname)//'.g98.out'
   molname = TRIM(proname)//'.xtbhess.xyz'
   call delete_files(3, [chgname, wboname, molname])
  end if
 end if
end subroutine submit_xtb_job

subroutine read_lat_vec_from_coord(coord, lat_vec)
 use phys_cons, only: Bohr_const
 implicit none
 integer :: fid
 real(kind=8), intent(out) :: lat_vec(3,3)
 character(len=240) :: buf
 character(len=240), intent(in) :: coord

 lat_vec = 0d0
 open(newunit=fid,file=TRIM(coord),status='old',position='append')

 do while(.true.)
  BACKSPACE(fid)
  BACKSPACE(fid)
  read(fid,'(A)') buf
  if(buf(1:8) == '$lattice') exit
 end do ! for while

 read(fid,*) lat_vec
 close(fid)
 lat_vec = lat_vec*Bohr_const
end subroutine read_lat_vec_from_coord

! add the lattice vector into a given. xyz file
subroutine add_lat_vec_into_xyz(xyzname, lat_vec)
 implicit none
 integer :: i, natom, fid, fid1, RENAME
 real(kind=8), intent(in) :: lat_vec(3,3)
 character(len=240) :: buf, xyzname1
 character(len=240), intent(in) :: xyzname

 xyzname1 = TRIM(xyzname)//'.t'
 open(newunit=fid,file=TRIM(xyzname),status='old',position='rewind')
 open(newunit=fid1,file=TRIM(xyzname1),status='replace')

 do while(.true.)
  read(fid,*,iostat=i) natom
  if(i /= 0) exit
  read(fid,'(A)') buf
  write(fid1,'(I0)') natom
  write(fid1,'(A,F0.3,8(1X,F0.3),A)') "Lattice=""", lat_vec, """"

  do i = 1, natom, 1
   read(fid,'(A)') buf
   write(fid1,'(A)') TRIM(buf)
  end do ! for i
 end do ! for while

 close(fid,status='delete')
 close(fid1)
 i = RENAME(TRIM(xyzname1), TRIM(xyzname))
end subroutine add_lat_vec_into_xyz

! merge two or more .xyz files
subroutine merge_xyz(proname, nfile, skip_first)
 implicit none
 integer :: i, j, natom, fid1, fid2, RENAME
 integer, intent(in) :: nfile
 character(len=240) :: proname1, proname2
 character(len=240), intent(in) :: proname
 character(len=300) :: buf
 logical, intent(in) :: skip_first
 ! whether to skip the 1st frame in the 2nd, 3rd, ... files

 if(nfile < 1) then
  write(6,'(/,A)') 'ERROR in subroutine merge_xyz: nfile<0.'
  write(6,'(A)') 'proname='//TRIM(proname)
  stop
 end if

 proname1 = TRIM(proname)//'_1.xyz'
 open(newunit=fid1,file=TRIM(proname1),status='old',position='append')

 do i = 2, nfile, 1
  write(proname2,'(A,I0,A)') TRIM(proname)//'_', i, '.xyz'
  open(newunit=fid2,file=TRIM(proname2),status='old',position='rewind')

  if(skip_first) then
   read(fid2,*) natom
   do j = 1, natom+1, 1
    read(fid2,'(A)') buf
   end do ! for j
  end if

  do while(.true.)
   read(fid2,*,iostat=j) natom
   if(j /= 0) exit
   write(fid1,'(I0)') natom
   do j = 1, natom+1, 1
    read(fid2,'(A)') buf
    write(fid1,'(A)') TRIM(buf)
   end do ! for j
  end do ! for while

  close(fid2,status='delete')
 end do ! for i

 close(fid1)
 proname2 = TRIM(proname)//'.xyz'
 i = RENAME(TRIM(proname1), TRIM(proname2))
end subroutine merge_xyz

subroutine merge_two_train_xyz(proname)
 implicit none
 integer :: i, natom, fid0, fid, RENAME
 character(len=240) :: xyzname0, xyzname
 character(len=240), intent(in) :: proname
 character(len=300) :: buf
 logical :: alive

 xyzname0 = TRIM(proname)//'_0.xyz'
 inquire(file=TRIM(xyzname0),exist=alive)
 if(.not. alive) return

 xyzname = TRIM(proname)//'.xyz'
 open(newunit=fid0,file=TRIM(xyzname0),status='old',position='append')
 open(newunit=fid,file=TRIM(xyzname),status='old',position='rewind')

 do while(.true.) ! skip the isolated atom section
  read(fid,*) natom
  if(natom == 1) then
   read(fid,'(A)') buf
   read(fid,'(A)') buf
  else
   BACKSPACE(fid)
   exit
  end if
 end do ! for while

 do while(.true.)
  read(fid,'(A)',iostat=i) buf
  if(i /= 0) exit
  write(fid0,'(A)') TRIM(buf)
 end do ! for while

 close(fid0)
 close(fid,status='delete')
 i = RENAME(TRIM(xyzname0), TRIM(xyzname))
end subroutine merge_two_train_xyz

! Split a .xyz file (with PBC systems) into multiple CP2K input files.
! Note:
! 1) The lattice parameters are supposed to be recorded in Lattice="" in the title
!  line of each frame in the .xyz file.
! 2) The total charge and spin multiplicity are required by this subroutine. I
!  hope users know what they are calculating and not just simply assign them as
!  '0 1'.
subroutine split_pbc_xyz_into_cp2k_inp(xyzname, charge, mult)
 implicit none
 integer :: i, j, natom, nfile, fid
 integer, intent(in) :: charge, mult
 real(kind=8) :: lat_vec(3,3)
 real(kind=8), allocatable :: coor(:,:)
 character(len=2), allocatable :: elem(:)
 character(len=240) :: proname, inpname
 character(len=240), intent(in) :: xyzname
 character(len=300) :: buf

 i = INDEX(xyzname, '.xyz', back=.true.)
 proname = xyzname(1:i-1)
 open(newunit=fid,file=TRIM(xyzname),status='old',position='rewind')
 nfile = 0

 do while(.true.)
  read(fid,'(A)',iostat=i) buf
  if(i /= 0) exit
  nfile = nfile + 1
  write(inpname,'(A,I0,A)') TRIM(proname)//'_', nfile, '.inp'
  read(buf,*) natom
  read(fid,'(A)') buf
  i = INDEX(buf, "Lattice=")
  j = INDEX(buf(i+9:), """")
  read(buf(i+9:i+7+j),*) lat_vec
  allocate(elem(natom), coor(3,natom))
  do i = 1, natom, 1
   read(fid,*) elem(i), coor(:,i)
  end do ! for i
  call write_cp2k_inp(inpname, charge, mult, natom, elem, coor, lat_vec)
  deallocate(elem, coor)
 end do ! for while

 close(fid)
end subroutine split_pbc_xyz_into_cp2k_inp

subroutine write_cp2k_inp(inpname, charge, mult, natom, elem, coor, lat_vec)
 implicit none
 integer :: i, fid
 integer, intent(in) :: charge, mult, natom
 real(kind=8), intent(in) :: coor(3,natom), lat_vec(3,3)
 character(len=2), intent(in) :: elem(natom)
 character(len=3), parameter :: dftname = 'PBE'
 character(len=240) :: proname
 character(len=240), intent(in) :: inpname

 call find_specified_suffix(inpname, '.inp', i)
 proname = inpname(1:i-1)

 open(newunit=fid,file=TRIM(inpname),status='replace')
 write(fid,'(A)') "&GLOBAL"
 write(fid,'(A)') ' PROJECT '//TRIM(proname)
 write(fid,'(A)') ' PRINT_LEVEL LOW'
 write(fid,'(A)') ' RUN_TYPE ENERGY_FORCE'
 write(fid,'(A)') "&END GLOBAL"

 write(fid,'(/,A)') "&FORCE_EVAL"
 write(fid,'(A)') ' METHOD QuickStep'
 write(fid,'(A)') " &SUBSYS"
 write(fid,'(A)') "  &CELL"
 write(fid,'(3X,A1,3(1X,F20.8))') 'A', lat_vec(:,1)
 write(fid,'(3X,A1,3(1X,F20.8))') 'B', lat_vec(:,2)
 write(fid,'(3X,A1,3(1X,F20.8))') 'C', lat_vec(:,3)
 write(fid,'(A)') '   PERIODIC XYZ'
 write(fid,'(A)') "  &END CELL"
 write(fid,'(A)') "  &COORD"
 do i = 1, natom, 1
  write(fid,'(3X,A2,3(1X,F20.8))') elem(i), coor(:,i)
 end do ! for i
 write(fid,'(A)') "  &END COORD"

 ! assume the same basis set is used for all atoms of an element
 do i = 1, natom, 1
  if(i > 1) then
   if( ANY(elem(1:i-1) == elem(i)) ) cycle
  end if
  write(fid,'(A)') "  &KIND "//TRIM(elem(i))
  write(fid,'(A)') '   ELEMENT '//TRIM(elem(i))
  write(fid,'(A)') '   BASIS_SET Ahlrichs-def2-TZVP'
  write(fid,'(A)') '   POTENTIAL ALL'
  write(fid,'(A)') "  &END KIND"
 end do ! for i
 write(fid,'(A)') " &END SUBSYS"

 write(fid,'(A)') " &DFT"
 write(fid,'(A)') '  BASIS_SET_FILE_NAME EMSL_BASIS_SETS'
 write(fid,'(A)') '  POTENTIAL_FILE_NAME POTENTIAL'
 write(fid,'(A,I0)') '  CHARGE ', charge
 write(fid,'(A,I0)') '  MULTIPLICITY ', mult
 write(fid,'(A)') "  &QS"
 write(fid,'(A)') '   EPS_DEFAULT 1E-12'
 write(fid,'(A)') '   METHOD GAPW'
 write(fid,'(A)') "  &END QS"
 write(fid,'(A)') "  &POISSON"
 write(fid,'(A)') '   PERIODIC XYZ'
 write(fid,'(A)') '   PSOLVER PERIODIC'
 write(fid,'(A)') "  &END POISSON"
 write(fid,'(A)') "  &XC"
 write(fid,'(A)') "   &XC_FUNCTIONAL "//TRIM(dftname)
 write(fid,'(A)') "   &END XC_FUNCTIONAL"
 write(fid,'(A)') "   &VDW_POTENTIAL"
 write(fid,'(A)') '    POTENTIAL_TYPE PAIR_POTENTIAL'
 write(fid,'(A)') "    &PAIR_POTENTIAL"
 write(fid,'(A)') '     PARAMETER_FILE_NAME dftd3.dat'
 write(fid,'(A)') '     TYPE DFTD3(BJ)'
 write(fid,'(A)') '     REFERENCE_FUNCTIONAL PBE'
 write(fid,'(A)') "    &END PAIR_POTENTIAL"
 write(fid,'(A)') "   &END VDW_POTENTIAL"
 write(fid,'(A)') "  &END XC"
 write(fid,'(A)') "  &MGRID"
 write(fid,'(A)') '   CUTOFF 900'
 write(fid,'(A)') '   REL_CUTOFF 90'
 write(fid,'(A)') '   NGRIDS 4'
 write(fid,'(A)') "  &END MGRID"
 write(fid,'(A)') "  &SCF"
 write(fid,'(A)') '   MAX_SCF 200'
 write(fid,'(A)') '   EPS_SCF 1E-6'
 write(fid,'(A)') "   &DIAGONALIZATION"
 write(fid,'(A)') '    ALGORITHM STANDARD'
 write(fid,'(A)') "   &END DIAGONALIZATION"
 write(fid,'(A)') "   &PRINT"
 write(fid,'(A)') "    &RESTART"
 write(fid,'(A)') '     BACKUP_COPIES 0'
 write(fid,'(A)') "    &END RESTART"
 write(fid,'(A)') "   &END PRINT"
 write(fid,'(A)') "  &END SCF"
 write(fid,'(A)') " &END DFT"
 write(fid,'(A)') " &PRINT"
 write(fid,'(A)') "  &FORCES ON"
 write(fid,'(A)') "  &END FORCES"
 write(fid,'(A)') "  &STRESS_TENSOR ON"
 write(fid,'(A)') "  &END STRESS_TENSOR"
 write(fid,'(A)') " &END PRINT"
 write(fid,'(A)') ' STRESS_TENSOR ANALYTICAL'
 write(fid,'(A)') "&END FORCE_EVAL"
 close(fid)
end subroutine write_cp2k_inp

subroutine gen_batch_script_cp2k(proname)
 use ml_info, only: mem, nproc, queue_type
 implicit none
 integer :: fid
 character(len=240) :: shname
 character(len=240), intent(in) :: proname

 if(queue_type /= 1) then
  write(6,'(/,A)') 'ERROR in subroutine gen_batch_script_cp2k: currently only t&
                   &he SLURM queue'
  write(6,'(A)') 'system is supported.'
  stop
 end if

 shname = TRIM(proname)//'.sh'
 open(newunit=fid,file=TRIM(shname),status='replace')
 write(fid,'(A)') '#!/bin/bash'
 write(fid,'(A)') '#SBATCH -J cp2k'
 write(fid,'(A)') '#SBATCH -e cp2k.err.%j'
 write(fid,'(A)') '#SBATCH -p small_s'
 write(fid,'(A)') '#SBATCH -N 1'
 write(fid,'(A,I0)') '#SBATCH -n ', nproc ! MPI parallelism
 write(fid,'(A)') '#SBATCH -c 1'
 write(fid,'(A,I0,A)') '#SBATCH --mem=', mem, 'MB'
 write(fid,'(A)') '#SBATCH --exclusive'
 write(fid,'(A)') '#SBATCH --exclude=cu003'
 write(fid,'(A)') 'module load gcc/9.2'
 write(fid,'(A)') 'source $HOME/software/cp2k-2024.1/tools/toolchain/install/setup'
 write(fid,'(A)') 'export PATH=$HOME/software/cp2k-2024.1/exe/local:$PATH'
 write(fid,'(A)') 'export OMP_NUM_THREADS=1'
 write(fid,'(A,I0,A)') 'mpirun -np ',nproc," cp2k.psmp $1.inp >$1.out 2>&1"
 close(fid)
end subroutine gen_batch_script_cp2k

subroutine clean_cp2k_err_files()
 implicit none
 integer :: i, j, k, fid, SYSTEM
 character(len=14), parameter :: txtname = 'clean_cp2k.txt'
 character(len=240) :: buf, sname

 i = SYSTEM('\ls -l cp2k.err.* >'//txtname)
 inquire(file=txtname,size=i)
 if(i == 0) then
  call delete_file(txtname)
  return
 end if
 open(newunit=fid,file=txtname,status='old',position='rewind')

 do while(.true.)
  read(fid,'(A)',iostat=i) buf
  if(i /= 0) exit
  i = LEN_TRIM(buf)
  j = INDEX(buf(1:i), ' ', back=.true.)
  inquire(file=buf(j+1:i), size=k)
  if(k == 0) call delete_file(buf(j+1:i))

  sname = 'slurm-'//buf(j+10:i)//'.out'
  inquire(file=TRIM(sname), size=k)
  if(k == 0) call delete_file(TRIM(sname))
 end do ! for while

 close(fid,status='delete')
end subroutine clean_cp2k_err_files

! submit a batch of CP2K jobs
subroutine submit_cp2k_jobs(proname, nframe)
 use ml_info, only: max_njobs
 implicit none
 integer :: i, j, n, SYSTEM
 integer, intent(in) :: nframe
 character(len=240) :: shname, proname1, inpname, wfnname
 character(len=240), intent(in) :: proname

 shname = TRIM(proname)//'.sh'
 n = min(nframe, max_njobs)
 call OMP_SET_DYNAMIC(.true.)
 call OMP_SET_NUM_THREADS(n)

!$omp parallel do default(private) shared(nframe, proname, shname)
 do i = 1, nframe, 1
!$omp critical
  write(proname1,'(A,I0)') TRIM(proname)//'_', i
!$omp end critical
  inpname = TRIM(proname1)//'.inp'
  wfnname = TRIM(proname1)//'-RESTART.wfn'
  j = SYSTEM('sbatch --wait '//TRIM(shname)//' '//TRIM(proname1))
  if(j == 0) call delete_file(inpname)
  call delete_file(wfnname)
 end do ! for i
!$omp end parallel do

 call clean_cp2k_err_files()
end subroutine submit_cp2k_jobs

! Check whether the SCF is converged for a CP2K single-point job. If not, delete
! the output file and create a new input file with new SCF keywords.
subroutine check_cp2k_scf_conv(outname, scf_conv)
 implicit none
 integer :: i, fid, fid1, RENAME
 character(len=240) :: inpname, inpname1, wfnname
 character(len=240), intent(in) :: outname
 character(len=300) :: buf
 logical :: abnormal
 logical, intent(out) :: scf_conv

 abnormal = .false.; scf_conv = .true.
 i = LEN_TRIM(outname) ! assuming the suffix is .out
 inpname = outname(1:i-4)//'.inp'
 inpname1 = outname(1:i-4)//'.t'
 wfnname = outname(1:i-4)//'-RESTART.wfn'

 open(newunit=fid,file=TRIM(outname),status='old',position='rewind')
 do while(.true.)
  read(fid,'(A)',iostat=i) buf
  if(i /= 0) exit
  if(buf(7:23) == 'SCF run converge') exit
  if(buf(2:10) == '* [ABORT]') then
   abnormal = .true.
   read(fid,'(A)') buf
   if(INDEX(buf,'SCF run NOT conv') > 0) scf_conv = .false.
   exit
  end if
 end do ! for while

 if(abnormal) then ! error termination
  if(scf_conv) then
   close(fid)
   write(6,'(/,A)') 'ERROR in subroutine check_cp2k_scf_conv: this error cannot&
                    & be identified.'
   write(6,'(A)') 'Filename='//TRIM(outname)
   stop
  end if
 else              ! normal termination
  close(fid)
  return
 end if

 close(fid,status='delete')
 open(newunit=fid,file=TRIM(inpname),status='old',position='rewind')
 open(newunit=fid1,file=TRIM(inpname1),status='replace')

 do while(.true.)
  read(fid,'(A)') buf
  if(INDEX(buf,'MAX_SCF') > 0) exit
  write(fid1,'(A)') TRIM(buf)
 end do ! for while

 write(fid1,'(A)') '   MAX_SCF 400'
 write(fid1,'(A)') '   EPS_SCF 2E-8'
 write(fid1,'(A)') "   &DIAGONALIZATION"
 write(fid1,'(A)') '    ALGORITHM STANDARD'
 write(fid1,'(A)') "   &END DIAGONALIZATION"
 write(fid1,'(A)') "   &MIXING"
 write(fid1,'(A)') '    METHOD BROYDEN_MIXING'
 write(fid1,'(A)') '    ALPHA 0.4'
 write(fid1,'(A)') '    NBROYDEN 4'
 write(fid1,'(A)') "   &END MIXING"

 do while(.true.)
  read(fid,'(A)') buf
  if(INDEX(buf,'END DIAG') > 0) exit
 end do ! for while

 do while(.true.)
  read(fid,'(A)',iostat=i) buf
  if(i /= 0) exit
  write(fid1,'(A)') TRIM(buf)
 end do ! for while

 close(fid,status='delete')
 close(fid1)
 i = RENAME(TRIM(inpname1), TRIM(inpname))
end subroutine check_cp2k_scf_conv

! Find CP2K failed jobs, add/change SCF keywords and re-submit them. If the
! SCF is unconverged again, this subroutine does not take care of this.
subroutine find_cp2k_failed_and_resubmit(proname, nframe)
 use ml_info, only: max_njobs
 implicit none
 integer :: i, j, n, SYSTEM
 integer, intent(in) :: nframe
 character(len=240) :: shname, proname1, inpname, outname, wfnname
 character(len=240), intent(in) :: proname
 logical :: scf_conv

 shname = TRIM(proname)//'.sh'
 n = min(nframe, max_njobs)
 call OMP_SET_DYNAMIC(.true.)
 call OMP_SET_NUM_THREADS(n)

!$omp parallel do default(private) shared(nframe, proname, shname)
 do i = 1, nframe, 1
!$omp critical
  write(proname1,'(A,I0)') TRIM(proname)//'_', i
!$omp end critical
  inpname = TRIM(proname1)//'.inp'
  outname = TRIM(proname1)//'.out'
  wfnname = TRIM(proname1)//'-RESTART.wfn'
  call check_cp2k_scf_conv(outname, scf_conv)
  if(.not. scf_conv) then
   write(6,'(A)') 'CP2K job failed. Trying to re-submit with modified settings:&
                  & '//TRIM(inpname)
   j = SYSTEM('sbatch --wait '//TRIM(shname)//' '//TRIM(proname1))
   if(j == 0) call delete_file(inpname)
   call delete_file(wfnname)
  end if
 end do ! for i
!$omp end parallel do

 call clean_cp2k_err_files()
end subroutine find_cp2k_failed_and_resubmit

subroutine transfer_force_stress2xyz(proname, nframe, del)
 use phys_cons, only: au2ev, Bohr_const, GPa2eVA3
 implicit none
 integer :: i, j, natom, fid, fid1, RENAME
 integer, intent(in) :: nframe
 real(kind=8) :: elec_e, stress(3,3)
 real(kind=8), allocatable :: coor(:,:), force(:,:)
 character(len=2), allocatable :: elem(:)
 character(len=240) :: buf, xyzname, xyzname1, outname
 character(len=240), intent(in) :: proname
 logical, intent(in) :: del ! whether to delete .out files

 xyzname = TRIM(proname)//'.xyz'
 xyzname1 = TRIM(proname)//'.t'
 open(newunit=fid,file=TRIM(xyzname),status='old',position='rewind')
 open(newunit=fid1,file=TRIM(xyzname1),status='replace')

 write(fid1,'(A)') '1'
 write(fid1,'(A)',advance='no') "Lattice=""50.0 0.0 0.0 0.0 50.0 0.0 0.0 0.0 50.0"""
 write(fid1,'(A)') " Properties=species:S:1:pos:R:3:forces:R:3 config_type=Isol&
                   &atedAtom energy=-13.595241664 pbc=""F F F"""
 write(fid1,'(A)') 'H  0.0 0.0 0.0  0.0 0.0 0.0'
 write(fid1,'(A)') '1'
 write(fid1,'(A)',advance='no') "Lattice=""50.0 0.0 0.0 0.0 50.0 0.0 0.0 0.0 50.0"""
 write(fid1,'(A)') " Properties=species:S:1:pos:R:3:forces:R:3 config_type=Isol&
                   &atedAtom energy=-2041.115929518 pbc=""F F F"""
 write(fid1,'(A)') 'O  0.0 0.0 0.0  0.0 0.0 0.0'

 do i = 1, nframe, 1
  read(fid,*) natom
  read(fid,'(A)') buf
  allocate(elem(natom), coor(3,natom), force(3,natom))
  elem = ' '; coor = 0d0
  do j = 1, natom, 1
   read(fid,*) elem(j), coor(:,j)
  end do ! for j

  write(outname,'(A,I0,A)') TRIM(proname)//'_', i, '.out'
  call read_efs_from_cp2k_out(outname, natom, elec_e, force, stress)
  if(del) call delete_file(outname)
  elec_e = elec_e*au2ev ! Hartree -> eV
  force = force*au2ev/Bohr_const ! Hartree/Bohr -> eV/A
  stress = stress*GPa2eVA3 ! GPa -> eV/A^3

  write(fid1,'(I0)') natom
  j = INDEX(buf, 'Prop')
  if(j > 0) buf(j:) = ' '
  write(fid1,'(A)',advance='no') TRIM(buf)//&
   " Properties=species:S:1:pos:R:3:forces:R:3 energy="
  write(fid1,'(F0.8)',advance='no') elec_e
  write(fid1,'(A)',advance='no') " stress="""
  write(fid1,'(F0.7,8(1X,F0.7))',advance='no') stress
  write(fid1,'(A)') """ pbc=""T T T"""
  do j = 1, natom, 1
   write(fid1,'(A,6(1X,F18.8))') TRIM(elem(j)), coor(:,j), force(:,j)
  end do ! for j
  deallocate(elem, coor, force)
 end do ! for i

 close(fid,status='delete')
 close(fid1)
 i = RENAME(TRIM(xyzname1), TRIM(xyzname))
end subroutine transfer_force_stress2xyz

subroutine gen_batch_script_mace_train(proname, restart)
 use ml_info, only: n_mlp, mem, nproc, use_gpu, queue_type, max_num_epochs
 implicit none
 integer :: i, j, fid, SYSTEM
 character(len=240) :: proname1, shname, xyzname, model, swa_model, outname
 character(len=240), intent(in) :: proname
 logical, intent(in) :: restart

 xyzname = TRIM(proname)//'.xyz'

 do i = 1, n_mlp, 1
  write(proname1,'(A,I0)') TRIM(proname)//'_', i
  j = SYSTEM('mkdir -p '//TRIM(proname1))
  j = SYSTEM('cp '//TRIM(xyzname)//' '//TRIM(proname1)//'/')
  shname = TRIM(proname1)//'.sh'
  model = TRIM(proname1)//'.model'
  swa_model = TRIM(proname1)//'_swa.model'
  outname = TRIM(proname1)//'.out'

  open(newunit=fid,file=TRIM(shname),status='replace')
  write(fid,'(A)') '#!/bin/bash'
  write(fid,'(A)') '#SBATCH -J mace'
  write(fid,'(A)') '#SBATCH -e mace.err.%j'
  if(use_gpu) then
   write(fid,'(A)') '#SBATCH -p GPU_s'
   write(fid,'(A)') '#SBATCH -N 1'
   write(fid,'(A)') '#SBATCH -n 1'
   write(fid,'(A)') '#SBATCH -c 1'
   write(fid,'(A)') '#SBATCH --gres=gpu:1'
   write(fid,'(A)') '#SBATCH --mem=4000MB'
  else
   write(fid,'(A)') '#SBATCH -p small_s'
   write(fid,'(A)') '#SBATCH -N 1'
   write(fid,'(A)') '#SBATCH -n 1'
   write(fid,'(A,I0)') '#SBATCH -c ', nproc
   write(fid,'(A,I0,A)') '#SBATCH --mem=', mem, 'MB'
   write(fid,'(A)') '#SBATCH --exclusive'
   write(fid,'(A)') '#SBATCH --exclude=cu003'
  end if
  write(fid,'(A)') 'source ~/.bashrc'
  write(fid,'(A)') 'conda activate mace-openmm'
  write(fid,'(A)') 'cd '//TRIM(proname1)//'/'
  write(fid,'(A)') "mace_run_train --name='"//TRIM(proname1)//"' \"
  write(fid,'(A)') " --train_file='"//TRIM(xyzname)//"' \"
  write(fid,'(A)') ' --valid_fraction=0.05 \'
  write(fid,'(A)') " --E0s='isolated' \"
  write(fid,'(A)') " --model='MACE' \"
  write(fid,'(A)') ' --num_interactions=2 \'
  write(fid,'(A)') ' --max_ell=2 \'
  write(fid,'(A)') " --hidden_irreps='128x0e + 128x1o' \"
  write(fid,'(A)') ' --num_cutoff_basis=5 \'
  write(fid,'(A)') ' --max_L=2 \'
  write(fid,'(A)') ' --correlation=2 \'
  write(fid,'(A)') ' --loss stress \'
  write(fid,'(A)') ' --r_max=4.5 \'
  write(fid,'(A)') ' --batch_size=5 \'
  write(fid,'(A)') ' --valid_batch_size=5 \'
  write(fid,'(A)') ' --eval_interval=1 \'
  write(fid,'(A,I0,A)') ' --max_num_epochs=',max_num_epochs,' \'
  write(fid,'(A)') ' --start_swa=15 \'
  write(fid,'(A)') ' --swa_energy_weight=1000 \'
  write(fid,'(A)') ' --ema \'
  write(fid,'(A)') ' --ema_decay=0.99 \'
  write(fid,'(A)') ' --amsgrad \'
  write(fid,'(A)') ' --compute_stress=True \'
  write(fid,'(A)') " --error_table='PerAtomRMSEstressvirials' \"
  write(fid,'(A)') " --default_dtype='float64' \"
  write(fid,'(A)') ' --swa \'
  write(fid,'(A)') ' --save_cpu \'
  if(use_gpu) then
   write(fid,'(A)') ' --device=cuda \'
  else
   write(fid,'(A)') ' --device=cpu \'
  end if
  if(restart) write(fid,'(A)') ' --restart_latest \'
  write(fid,'(A,I0,A)') ' --seed=', NINT(1000d0/DBLE(i)), ' \'
  write(fid,'(A)') ' >'//TRIM(outname)//" 2>&1"

  write(fid,'(/,A)') '/bin/mv '//TRIM(swa_model)//' '//TRIM(model)
  write(fid,'(A)') 'rm -f '//TRIM(outname)
  close(fid)
 end do ! for i
end subroutine gen_batch_script_mace_train

subroutine submit_mace_jobs(proname, njobs)
 use ml_info, only: max_njobs, queue_type
 implicit none
 integer :: i, j, k, n, fid, SYSTEM
 integer, intent(in) :: njobs
 character(len=14), parameter :: txtname = 'clean_mace.txt'
 character(len=240) :: buf, proname1, shname, sname
 character(len=240), intent(in) :: proname
 character(len=485) :: xyzname

 n = min(njobs, max_njobs)
 call OMP_SET_DYNAMIC(.true.)
 call OMP_SET_NUM_THREADS(n)

!$omp parallel do default(private) shared(proname,njobs)
 do i = 1, njobs, 1
!$omp critical
  write(proname1,'(A,I0)') TRIM(proname)//'_', i
!$omp end critical
  shname = TRIM(proname1)//'.sh'
  xyzname = TRIM(proname1)//'/'//TRIM(proname)//'.xyz'
  j = SYSTEM('sbatch --wait '//TRIM(shname))
  if(j == 0) then
   call delete_file(TRIM(shname))
   call delete_file(TRIM(xyzname))
  end if
 end do ! for i
!$omp end parallel do

 i = SYSTEM('\ls -l mace.err.* >'//txtname)
 open(newunit=fid,file=txtname,status='old',position='rewind')

 do while(.true.)
  read(fid,'(A)',iostat=i) buf
  if(i /= 0) exit
  i = LEN_TRIM(buf)
  j = INDEX(buf(1:i), ' ', back=.true.)
  inquire(file=buf(j+1:i), size=k)
  if(k == 0) call delete_file(buf(j+1:i))

  sname = 'slurm-'//buf(j+10:i)//'.out'
  inquire(file=TRIM(sname), size=k)
  if(k == 0) call delete_file(TRIM(sname))
 end do ! for while

 close(fid,status='delete')
end subroutine submit_mace_jobs

subroutine gen_batch_script_mace_md(proname, long_md)
 use ml_info, only: mem, nproc, use_gpu, ntraj, t_range
 implicit none
 integer :: i, j, fid, SYSTEM
 character(len=240) :: proname1, shname, pyname, ini_xyz, traj_pdb, model1, &
  traj_xyz, chkname, outname
 character(len=240), intent(in) :: proname
 character(len=500) :: model
 logical, intent(in) :: long_md

 model = TRIM(proname)//'_1/'//TRIM(proname)//'_1.model'
 ini_xyz = TRIM(proname)//'_md.xyz'

 do i = 1, ntraj, 1
  write(traj_xyz,'(A,I0,A)') TRIM(proname)//'_eval_', i, '.xyz'
  write(proname1,'(A,I0)') TRIM(proname)//'_md_', i
  j = SYSTEM('mkdir -p '//TRIM(proname1))
  shname = TRIM(proname1)//'.sh'
  pyname = TRIM(proname1)//'.py'
  outname = TRIM(proname1)//'.out'
  model1 = TRIM(proname1)//'.model'
  traj_pdb = TRIM(proname1)//'.pdb'
  chkname = TRIM(proname1)//'.chk'
  call sys_copy_file(TRIM(model), TRIM(proname1)//'/'//TRIM(model1), .false.)
  j = SYSTEM('cp '//TRIM(ini_xyz)//' '//TRIM(proname1)//'/')

  open(newunit=fid,file=TRIM(shname),status='replace')
  write(fid,'(A)') '#!/bin/bash'
  write(fid,'(A)') '#SBATCH -J mace'
  write(fid,'(A)') '#SBATCH -e mace.err.%j'
  if(use_gpu) then
   write(fid,'(A)') '#SBATCH -p GPU_s'
   write(fid,'(A)') '#SBATCH -N 1'
   write(fid,'(A)') '#SBATCH -n 1'
   write(fid,'(A)') '#SBATCH -c 1'
   write(fid,'(A)') '#SBATCH --gres=gpu:1'
   write(fid,'(A)') '#SBATCH --mem=4000MB'
  else
   write(fid,'(A)') '#SBATCH -p small_s'
   write(fid,'(A)') '#SBATCH -N 1'
   write(fid,'(A)') '#SBATCH -n 1'
   write(fid,'(A,I0)') '#SBATCH -c ', nproc
   write(fid,'(A,I0,A)') '#SBATCH --mem=',mem,'MB'
   write(fid,'(A)') '#SBATCH --exclusive'
   write(fid,'(A)') '#SBATCH --exclude=cu003'
  end if
  write(fid,'(A)') 'source ~/.bashrc # make (base) valid'
  write(fid,'(A)') 'conda activate mace-openmm'
  write(fid,'(A)') 'cd '//TRIM(proname1)//'/'
  write(fid,'(A)') 'python '//TRIM(pyname)//' >'//TRIM(outname)//" 2>&1"
  !write(fid,'(A)') '/bin/mv '//TRIM(traj_xyz)//' ../'
  !write(fid,'(A)') 'rm -f '//TRIM(pyname)
  close(fid)

  open(newunit=fid,file=TRIM(pyname),status='replace')
  write(fid,'(A)') 'from openmmtools.openmm_torch.hybrid_md import PureSystem'
  write(fid,'(A)') 'import mdtraj as md'
  write(fid,'(A)') 'from os import remove, rename'
  write(fid,'(A)') 'from shutil import rmtree'
  write(fid,'(A)') 'import torch'
  write(fid,'(A)') 'torch.set_default_dtype(torch.float64)'
  write(fid,'(A)') "xyzname='"//TRIM(ini_xyz)//"'"
  write(fid,'(/,A)') 'system=PureSystem(file=xyzname,ml_mol=xyzname,'
  write(fid,'(A)') "  model_path='"//TRIM(model1)//"',"
  write(fid,'(A)') "  output_dir='./',"
  write(fid,'(A)') "  potential='mace',"
  write(fid,'(A,F0.2,A)') '  temperature=',t_range(i),','
  write(fid,'(A)') '  pressure=1.0,'
  write(fid,'(A)') "  nl='torch',"
  write(fid,'(A)') '  max_n_pairs=-1,'
  write(fid,'(A)') '  timestep=0.5,'
  if(use_gpu) then
   write(fid,'(A)') "  minimiser='ase',"
  else
   write(fid,'(A)') "  minimiser='openmm',"
  end if
  write(fid,'(A)') '  remove_cmm=True, unwrap=False)'
  write(fid,'(/,A)',advance='no') 'system.run_mixed_md(steps='
  if(long_md) then
   write(fid,'(A)') '10000,interval=50,'
  else
   write(fid,'(A)') '500,interval=25,' !1000
  end if
  write(fid,'(A)') "  integrator_name='nose-hoover',"
  write(fid,'(A)') "  output_file='"//TRIM(traj_pdb)//"',"
  write(fid,'(A)') '  restart=False)'

  ! The .xyz file generated by save_xyz() in MDTraj only has 3 digits of
  ! Cartesian coordinates due to the usage of pdb file. So I have to create
  ! a formatted .xyz file using python.
  write(fid,'(/,A)') "t = md.load('output.dcd', top='minimised_system.pdb')"
  write(fid,'(A)') 't.unitcell_vectors *= 10.0 # nm to A'
  write(fid,'(A)') 't.xyz *= 10.0 # nm to A'
  write(fid,'(A)') "f = open('output.xyz', 'w+')"
  write(fid,'(/,A)') 'for i in range(t.n_frames):'
  write(fid,'(A)') '  f.write(str(t.n_atoms))'
  write(fid,'(A)') "  f.write('\nLattice=\""')"
  write(fid,'(A)') "  f.write(' '.join(map(str,t.unitcell_vectors[i,:,:].flatten())))"
  write(fid,'(A)') "  f.write('\"" Properties=species:S:1:pos:R:3 pbc=""T T T""\n')"
  write(fid,'(A)') '  for j in range(t.n_atoms):'
  write(fid,'(A)') "    f.write(t.topology.atom(j).element.symbol+'  ')"
  write(fid,'(A)') "    f.write('  '.join(format(x,'.8f') for x in t.xyz[i,j,:]))"
  write(fid,'(A)') "    f.write('\n')"
  write(fid,'(/,A)') 'f.close()'
  !write(fid,'(A)') "remove('minimised_system.pdb')"
  !write(fid,'(A)') "remove('minimised.xyz')"
  !write(fid,'(A)') "remove('output.dcd')"
  !write(fid,'(A)') "remove('"//TRIM(chkname)//"')"
  !write(fid,'(A)') "remove('"//TRIM(model1)//"')"
  !write(fid,'(A)') "remove('"//TRIM(traj_pdb)//"')"
  !write(fid,'(A)') "rename('output.xyz', '"//TRIM(traj_xyz)//"')"
  !write(fid,'(A)') "rmtree('compiled_models')"
  close(fid)

  j = SYSTEM('/bin/mv '//TRIM(pyname)//' '//TRIM(proname1)//'/')
 end do ! for i
end subroutine gen_batch_script_mace_md

subroutine gen_batch_script_mace_eval(proname)
 use ml_info, only: n_mlp, mem, nproc, use_gpu, queue_type
 implicit none
 integer :: i, j, fid, SYSTEM
 character(len=240) :: proname1, shname, xyzname, xyzname1, model, outname
 character(len=240), intent(in) :: proname

 xyzname = TRIM(proname)//'_eval.xyz'

 do i = 1, n_mlp, 1
  write(proname1,'(A,I0)') TRIM(proname)//'_', i
  model = TRIM(proname1)//'.model'
  shname = TRIM(proname1)//'.sh'
  outname = TRIM(proname1)//'.out'
  xyzname1 = TRIM(proname1)//'.xyz'
  j = SYSTEM('cp '//TRIM(xyzname)//' '//TRIM(proname1)//'/'//TRIM(xyzname))

  open(newunit=fid,file=TRIM(shname),status='replace')
  write(fid,'(A)') '#!/bin/bash'
  write(fid,'(A)') '#SBATCH -J mace'
  write(fid,'(A)') '#SBATCH -e mace.err.%j'
  if(use_gpu) then
   write(fid,'(A)') '#SBATCH -p GPU_s'
   write(fid,'(A)') '#SBATCH -N 1'
   write(fid,'(A)') '#SBATCH -n 1'
   write(fid,'(A)') '#SBATCH -c 1'
   write(fid,'(A)') '#SBATCH --gres=gpu:1'
   write(fid,'(A)') '#SBATCH --mem=4000MB'
  else
   write(fid,'(A)') '#SBATCH -p small_s'
   write(fid,'(A)') '#SBATCH -N 1'
   write(fid,'(A)') '#SBATCH -n 1'
   write(fid,'(A,I0)') '#SBATCH -c ', nproc
   write(fid,'(A,I0,A)') '#SBATCH --mem=', mem, 'MB'
   write(fid,'(A)') '#SBATCH --exclusive'
   write(fid,'(A)') '#SBATCH --exclude=cu003'
  end if
  write(fid,'(A)') 'source ~/.bashrc'
  write(fid,'(A)') 'conda activate mace-openmm'
  write(fid,'(A)') 'cd '//TRIM(proname1)//'/'
  write(fid,'(A)') "mace_eval_configs --configs='"//TRIM(xyzname)//"' \"
  write(fid,'(A)') " --model='"//TRIM(model)//"' \"
  write(fid,'(A)') " --output='"//TRIM(xyzname1)//"' \"
  write(fid,'(A)') " --default_dtype='float64' \"
  if(use_gpu) then
   write(fid,'(A)') ' --device=cuda \'
  else
   write(fid,'(A)') ' --device=cpu \'
  end if
  write(fid,'(A)') ' >'//TRIM(outname)//" 2>&1"

  write(fid,'(/,A)') 'rm -f '//TRIM(xyzname)//' '//TRIM(outname)
  write(fid,'(A)') '/bin/mv '//TRIM(xyzname1)//' ../'
  close(fid)
 end do ! for i
end subroutine gen_batch_script_mace_eval

subroutine find_e_f_diff(proname, nframe)
 use ml_info, only: n_mlp, mlp_e_diff, mlp_f_diff
 implicit none
 integer :: i, j, k, m, natom, ncalc, ncalc1, ncalc2, fid, fid1, RENAME
 integer, intent(inout) :: nframe
 real(kind=8) :: e, e1, rtmp(3)
 real(kind=8), allocatable :: force(:,:), force1(:,:)
 character(len=2) :: elem
 character(len=240) :: xyzname, xyzname0, xyzname1
 character(len=240), intent(in) :: proname
 character(len=300) :: buf, buf1
 logical, allocatable :: e_devi(:), f_devi(:) ! size nframe
 ! arrays to record large energy deviation and large force deviation

 allocate(e_devi(nframe), f_devi(nframe))
 e_devi = .false.; f_devi = .false.

 xyzname1 = TRIM(proname)//'_1.xyz'
 open(newunit=fid1,file=TRIM(xyzname1),status='old',position='rewind')

 do i = 2, n_mlp, 1
  if(i > 2) rewind(fid1)
  write(xyzname,'(A,I0,A)') TRIM(proname)//'_', i, '.xyz'
  open(newunit=fid,file=TRIM(xyzname),status='old',position='rewind')

  do j = 1, nframe, 1
   read(fid1,*) natom
   read(fid1,'(A)') buf1
   if(e_devi(j) .or. f_devi(j)) then
    do k = 1, natom, 1
     read(fid1,'(A)') buf1
    end do ! for k
    do k = 1, natom+2, 1
     read(fid,'(A)') buf
    end do ! for k
   else
    read(fid,*) natom
    read(fid,'(A)') buf
    call read_e_from_buf_in_xyz(TRIM(buf1), e1)
    call read_e_from_buf_in_xyz(TRIM(buf), e)
    if(DABS(e1-e) > mlp_e_diff) e_devi(j) = .true.
    if(e_devi(j)) then
     do k = 1, natom, 1
      read(fid1,'(A)') buf1
     end do ! for k
     do k = 1, natom, 1
      read(fid,'(A)') buf
     end do ! for k
    else
     allocate(force1(3,natom), force(3,natom))
     do k = 1, natom, 1
      read(fid1,*) elem, rtmp, force1(:,k)
     end do ! for k
     do k = 1, natom, 1
      read(fid,*) elem, rtmp, force(:,k)
     end do ! for k
     force1 = force1 - force
     forall(k=1:3, m=1:natom) force1(k,m) = force1(k,m)*force1(k,m)
     rtmp(1) = DSQRT(SUM(force1)/DBLE(3*natom))
     if(rtmp(1) > mlp_f_diff) f_devi(j) = .true.
     deallocate(force1, force)
    end if
   end if
  end do ! for j

  close(fid,status='delete')
  ncalc1 = COUNT(e_devi .eqv. .true.)
  ncalc2 = COUNT(f_devi .eqv. .true.)

  ! if ab initio calc. must be performed for all structures
  if(ncalc1+ncalc2 == nframe) then
   do j = i+1, n_mlp, 1
    write(xyzname,'(A,I0,A)') TRIM(proname)//'_', j, '.xyz'
    call delete_file(TRIM(xyzname))
   end do ! for j
   exit
  end if
 end do ! for i

 close(fid1)
 ncalc1 = COUNT(e_devi .eqv. .true.)
 write(6,'(A,I0)') 'No. frames to do ab initio calc. due to e_diff: ', ncalc1
 ncalc2 = COUNT(f_devi .eqv. .true.)
 write(6,'(A,I0)') 'No. frames to do ab initio calc. due to f_diff: ', ncalc2
 ncalc = ncalc1 + ncalc2

 ! if not all structures need to be calculated using DFT/WFT
 if(ncalc>0 .and. ncalc<nframe) then
  forall(i = 1:nframe, f_devi(i)) e_devi(i) = .true.
  open(newunit=fid1,file=TRIM(xyzname1),status='old',position='rewind')
  xyzname = TRIM(proname)//'_0.xyz'
  open(newunit=fid,file=TRIM(xyzname),status='replace')
  do i = 1, nframe, 1
   read(fid1,*) natom
   if(e_devi(i)) then
    write(fid,'(I0)') natom
    do j = 1, natom+1, 1
     read(fid1,'(A)') buf
     write(fid,'(A)') TRIM(buf)
    end do ! for j
   else
    do j = 1, natom+1, 1
     read(fid1,'(A)') buf
    end do ! for j
   end if
  end do ! for i
  close(fid)
  close(fid1,status='delete')
  i = RENAME(TRIM(xyzname), TRIM(xyzname1))
 end if

 deallocate(e_devi, f_devi)
 xyzname = TRIM(proname)//'_eval.xyz'
 call delete_file(TRIM(xyzname))

 xyzname = TRIM(proname)//'.xyz'
 xyzname0 = TRIM(proname)//'_0.xyz'
 i = RENAME(TRIM(xyzname), TRIM(xyzname0))
 i = RENAME(TRIM(xyzname1), TRIM(xyzname))
 nframe = ncalc   ! update nframe

 call del_unreasonable_geom_in_xyz(xyzname, nframe)
 write(6,'(A)') 'After exluding unreasonable geometries,'
 write(6,'(A,I0)') 'No. frames to do ab initio calculations: ', nframe
end subroutine find_e_f_diff

subroutine read_e_from_buf_in_xyz(buf, e)
 implicit none
 integer :: i, j
 real(kind=8), intent(out) :: e
 character(len=*), intent(in) :: buf

 e = 0d0
 i = INDEX(buf, 'energy=')
 j = INDEX(buf, 'pbc')
 if(i==0 .or. j==0) then
  write(6,'(/,A)') 'ERROR in subroutine read_e_from_buf_in_xyz: cannot locate e&
                   &nergy in buf.'
  write(6,'(A)') "buf='"//TRIM(buf)//"'"
  stop
 end if
 if(i > j) then
  write(6,'(/,A)') 'ERROR in subroutine read_e_from_buf_in_xyz: wrong data order.'
  write(6,'(A)') 'pbc data must be put after the energy data.'
  stop
 end if
 read(buf(i+7:j-2),*) e
end subroutine read_e_from_buf_in_xyz

! delete unreasonable geometries in a .xyz file
subroutine del_unreasonable_geom_in_xyz(xyzname, nframe)
 implicit none
 integer :: i, j, k, m, i1, i2, fid, fid1, natom, natom1, charge, mult, RENAME
 integer, intent(inout) :: nframe
 integer, allocatable :: nuc(:), conn(:,:)
 real(kind=8) :: lat_vec(3,3)
 real(kind=8), allocatable :: coor(:,:), dis(:,:)
 character(len=2), allocatable :: elem(:)
 character(len=240) :: gjfname, new_gjf, xyzname1
 character(len=240), intent(in) :: xyzname
 character(len=300) :: buf
 logical, allocatable :: reasonable(:)

 allocate(reasonable(nframe))
 reasonable = .true.

 call find_specified_suffix(xyzname, '.xyz', k)
 xyzname1 = xyzname(1:k-1)//'.t'

 open(newunit=fid,file=TRIM(xyzname),status='old',position='rewind')
 open(newunit=fid1,file=TRIM(xyzname1),status='replace')

 do i = 1, nframe, 1
  read(fid,*) natom
  allocate(elem(natom+3), coor(3,natom+3))
  elem(natom+1:natom+3) = 'Tv'

  read(fid,'(A)') buf
  i1 = INDEX(buf, "Lattice=")
  i2 = INDEX(buf(i1+9:), """")
  read(buf(i1+9:i1+7+i2),*) coor(:,natom+1:natom+3)

  do j = 1, natom, 1
   read(fid,*) elem(j), coor(:,j)
  end do ! for j

  call get_a_random_int(m)
  write(gjfname,'(A,I0,A)') xyzname(1:k-1)//'_',m,'.gjf'
  write(new_gjf,'(A,I0,A)') xyzname(1:k-1)//'_',m,'_new.gjf'
  call write_gjf(gjfname, 0, 1, natom+3, elem, coor)
  deallocate(elem, coor)

  ! Complement atoms around the cell. The subroutine complement_mol_around_cell
  ! is designed to complement molecules around the cell. But if the distance
  ! threshold is set to be very small, it is equivalent to choose the closest
  ! atoms out of the cell box.
  ! Note: this subroutine allows that the positions of somes atoms (which belong
  !  to the cell) can be out of the cell box.
  call complement_mol_around_cell(gjfname, 0.01d0)
  call delete_file(TRIM(gjfname))
  call read_natom_from_gjf_pbc(new_gjf, natom1)
  allocate(elem(natom1), nuc(natom1), coor(3,natom1))
  call read_elem_and_coor_from_gjf_pbc(new_gjf, natom1, elem, nuc, coor, &
                                       lat_vec, charge, mult)
  call delete_file(TRIM(new_gjf))

  ! get connectivities from Cartesian coordinates
  allocate(dis(natom1,natom1), conn(natom1,natom1))
  call gen_conn_from_coor(natom1, coor, nuc, dis, conn)
  deallocate(dis)
  call check_conn_reasonable(natom1, nuc, conn, reasonable(i))
  deallocate(nuc, conn)

  if(reasonable(i)) then
   write(fid1,'(I0)') natom
   j = INDEX(buf, ':MACE_forces:R:3')
   m = INDEX(buf, ' pbc=')
   buf = buf(1:j-1)//TRIM(buf(m:))
   write(fid1,'(A)') TRIM(buf)
   do j = 1, natom, 1
    write(fid1,'(A2,3(1X,F18.8))') elem(j), coor(:,j)
   end do ! for j
  end if

  deallocate(elem, coor)
 end do ! for i

 nframe = COUNT(reasonable .eqv. .true.)
 deallocate(reasonable)

 if(nframe == 0) then
  write(6,'(/,A)') 'ERROR in subroutine del_unreasonable_geom_in_xyz: none of s&
                   &tructures generated'
  write(6,'(A)') 'by MLP is reasonable. Probably because your provided data set&
                 & is too small.'
  close(fid)
  close(fid1,status='delete')
  stop
 end if

 close(fid,status='delete')
 close(fid1)
 i = RENAME(TRIM(xyzname1), TRIM(xyzname))
end subroutine del_unreasonable_geom_in_xyz

