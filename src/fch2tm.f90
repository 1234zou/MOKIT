! written by jxzou at 20240212: generate Turbomole files from a Gaussian .fch(k) file

program main
 use util_wrapper, only: formchk
 implicit none
 integer :: i, k
 character(len=240) :: fchname

 i = iargc()
 if(i /= 1) then
  write(6,'(/,A)') ' ERROR in subroutine fch2tm: wrong command line argument!'
  write(6,'(A,/)') ' Example: fch2tm h2o.fch'
  stop
 end if

 call getarg(1,fchname)
 call require_file_exist(fchname)

 ! if .chk file provided, convert into .fch file automatically
 k = LEN_TRIM(fchname)
 if(fchname(k-3:k) == '.chk') then
  call formchk(fchname)
  fchname = fchname(1:k-3)//'fch'
 end if

 call fch2tm(fchname)
end program main

! generate Turbomole control file from a specified Gaussian .fch(k) file
subroutine fch2tm(fchname)
 use fch_content
 implicit none
 integer :: i, j, k, m, n, n1, n2, nif1, length, fid
 integer :: n5dmark, n7fmark, n9gmark, n11hmark
 integer :: n6dmark, n10fmark, n15gmark, n21hmark
 integer, allocatable :: idx(:), ia1(:), ia2(:)
 integer, allocatable :: d_mark(:), f_mark(:), g_mark(:), h_mark(:)
 real(kind=8), allocatable :: norm(:), coeff0(:,:), coeff(:,:)
 character(len=1) :: str = ' '
 character(len=1), parameter :: am_type(0:6) = ['s','p','d','f','g','h','i']
 character(len=240), intent(in) :: fchname
 logical :: uhf, ecp, sph, has_sp

 uhf = .false.; ecp = .false.; has_sp = .false.
 call check_nosymm_in_fch(fchname)
 call check_uhf_in_fch(fchname, uhf) ! determine whether UHF
 call read_fch(fchname, uhf) ! read content in .fch(k) file

 if(uhf) then
  nif1 = 2*nif ! alpha+beta MOs
  allocate(coeff(nbf,nif1))
  coeff(:,1:nif) = alpha_coeff
  coeff(:,nif+1:nif1) = beta_coeff
  deallocate(beta_coeff)
 else
  nif1 = nif
  allocate(coeff(nbf,nif), source=alpha_coeff)
 end if
 deallocate(alpha_coeff)

 ! check whether spherical harmonic/Cartesian-type functions are used
 if(ANY(shell_type<-1) .and. ANY(shell_type>1)) then
  write(6,'(A)') 'ERROR in subroutine fch2tm: mixed spherical harmonic/Cartesia&
                 &n functions detected.'
  write(6,'(A)') 'You probably used a basis set like 6-31G(d) in Gaussian. Its &
                 &default setting is (6D,7F).'
  write(6,'(A)') "You need to add '5D 7F' or '6D 10F' keywords in Gaussian inpu&
                 &t file."
  stop
 else if( ANY(shell_type>1) ) then
  sph = .false.
  write(6,'(/,A)') 'ERROR in subroutine fch2tm: Cartesian-type (6D,10F) functio&
                   &ns not supported yet.'
  write(6,'(A)') 'Please use spherical harmonic (5D,7F) functions.'
  stop
 else
  sph = .true.
 end if
 if(ANY(shell_type == -1)) has_sp = .true.
 if(LenNCZ > 0) ecp = .true.

 do i = 1, natom, 1
  call lower(elem(i))
 end do ! for i

 open(newunit=fid,file='control',status='replace')
 write(fid,'(A,/,A)') '$title', 'generated by fch2tm of MOKIT'
 write(fid,'(A)') '$maxcor 500 MiB per_core'
 write(fid,'(A)') '$symmetry c1'
 write(fid,'(A)') '$coord'
 coor = coor/Bohr_const
 do i = 1, natom, 1
  write(fid,'(3(1X,F20.10),3X,A)') coor(:,i), TRIM(elem(i))
 end do ! for i

 write(fid,'(A)') '$atoms'
 do i = 1, natom, 1
  write(fid,'(A,2X,I0,5X,A)') TRIM(elem(i)), i, '\'
  if(ecp) then ! ECP/PP
   if(LPSkip(i) == 0) then
    write(fid,'(A,5X,A)') '   basis ='//TRIM(elem(i))//' gen','\'
    write(fid,'(A)') '   ecp   ='//TRIM(elem(i))//' ecp'
   else
    write(fid,'(A)') '   basis ='//TRIM(elem(i))//' gen'
   end if
  else         ! all-electron basis set
   write(fid,'(A)') '   basis ='//TRIM(elem(i))//' gen'
  end if
 end do ! for i
 write(fid,'(A,/,A)') '$basis', '*'
 write(fid,'(A,/,A)') TRIM(elem(1))//' gen', '*'
 k = 0
 do i = 1, ncontr, 1
  m = shell2atom_map(i)
  if(m > 1) then
   if(shell2atom_map(i-1) == m-1) then
    write(fid,'(A,/,A)') TRIM(elem(m))//' gen', '*'
   end if
  end if

  m = shell_type(i); n = prim_per_shell(i)
  if(m == -1) then
   write(fid,'(2X,I2,2X,A1)') n, am_type(0)
   do j = k+1, k+n, 1
    write(fid,'(2(2X,ES15.8))') prim_exp(j), contr_coeff(j)
   end do ! for j
   write(fid,'(2X,I2,2X,A1)') n, am_type(1)
   do j = k+1, k+n, 1
    write(fid,'(2(2X,ES15.8))') prim_exp(j), contr_coeff_sp(j)
   end do ! for j
  else ! m /= -1
   if(m < -1) m = -m
   write(fid,'(2X,I2,2X,A1)') n, am_type(m)
   do j = k+1, k+n, 1
    write(fid,'(2(2X,ES15.8))') prim_exp(j), contr_coeff(j)
   end do ! for j
  end if

  if(i == ncontr) then
   write(fid,'(A)') '*'
  else ! i < ncontr
   if(shell2atom_map(i+1) == shell2atom_map(i)+1) write(fid,'(A)') '*'
  end if

  k = k + n
 end do ! for i

 k = shell2atom_map(ncontr)
 if(k < natom) then
  write(6,'(/,A)') 'ERROR in subroutine fch2tm: k<natom. Internal inconsistency.'
  stop
 end if

 if(ecp) then
  write(fid,'(A,/,A)') '$ecp', '*'

  do i = 1, natom, 1
   if(LPSkip(i) /= 0) cycle
   write(fid,'(A,/,A)') TRIM(elem(i))//' ecp', '*'
   write(fid,'(2(3X,A,I0))') 'ncore = ', NINT(RNFroz(i)), 'lmax = ', LMax(i)
   str = am_type(LMax(i))
   do j = 1, 10, 1
    n1 = KFirst(i,j); n2 = KLast(i,j)
    if(n1 == 0) exit
    if(j == 1) then
     write(fid,'(A)') str
    else
     write(fid,'(A)') am_type(j-2)//'-'//str
    end if
    do n = n1, n2, 1
     write(fid,'(3X,ES15.8,3X,I2,2X,ES15.8)') CLP(n), NLP(n), ZLP(n)
    end do ! for n
   end do ! for j
   write(fid,'(A)') '*'
  end do ! for i
 end if

 if(sph) then
  write(fid,'(A)') '$pople AO'
 else
  write(fid,'(A)') '$pople CAO'
 end if
 if(uhf) then
  write(fid,'(A)') '$uhfmo_alpha file=mos'
  write(fid,'(A)') '$uhfmo_beta file=mos'
 else
  write(fid,'(A)') '$scfmo file=mos'
 end if
 write(fid,'(A)') '$scfiterlimit 200'
 write(fid,'(A)') '$scfconv 8'
 write(fid,'(A)') '$scfdamp start=0.0 step=0.0 min=0.0'
 !write(fid,'(A)') '$scforbitalshift noautomatic'
 if(uhf) then ! UHF
  write(fid,'(A)') '$uhf'
  write(fid,'(A)') '$alpha shells'
  write(fid,'(A,I0,A)') ' a  1-', na, '  ( 1 )'
  write(fid,'(A)') '$beta shells'
  write(fid,'(A,I0,A)') ' a  1-', nb, '  ( 1 )'
 else         ! RHF or high spin ROHF
  write(fid,'(A)') '$closed shells'
  write(fid,'(A,I0,A)') ' a  1-', nb, '  ( 2 )'
  if(mult > 1) then
   write(fid,'(A)') '$open shells type=1'
   write(fid,'(2(A,I0),A)') ' a  ', nb+1, '-', na, '  ( 1 )'
   write(fid,'(A)') '$roothaan         1'
   write(fid,'(A)') ' a=1  b=2'
  end if
 end if
 write(fid,'(A)') '$end'
 close(fid)

 ! 1) split the 'L' into 'S' and 'P', this is to ensure that D comes after L functions
 if(has_sp) then
  k = ncontr
  allocate(ia1(k), source=shell_type)
  allocate(ia2(k), source=shell2atom_map)
  deallocate(shell_type, shell2atom_map)
  allocate(shell_type(2*k), source=0)
  allocate(shell2atom_map(2*k), source=0)
  shell_type(1:k) = ia1; shell2atom_map(1:k) = ia2
  deallocate(ia1, ia2)
  call split_L_func(k, shell_type, shell2atom_map, length)
 else
  length = ncontr
 end if

 ! 2) sort the shell_type and shell2atom_map by ascending order
 allocate(idx(nbf))
 forall(i = 1:nbf) idx(i) = i ! initialization
 call sort_shell_and_mo_idx(length, shell_type, shell2atom_map, nbf, idx)

 ! 3) adjust the basis functions in each MO according to the type of basis
 !    functions
 k = length  ! update k
 allocate(d_mark(k), f_mark(k), g_mark(k), h_mark(k))
 allocate(norm(nbf), source=1d0)
 allocate(coeff0(nbf,nif1), source=coeff)
 if(sph) then
  call read_mark_from_shltyp_sph(k, shell_type, n5dmark, n7fmark, n9gmark, &
                                 n11hmark, d_mark, f_mark, g_mark, h_mark)
  call fch2tm_permute_sph(n5dmark, n7fmark, n9gmark, n11hmark, k, d_mark, &
                          f_mark, g_mark, h_mark, nbf, idx, norm)
 else
  call read_mark_from_shltyp_cart(k, shell_type, n6dmark, n10fmark, n15gmark, &
                                  n21hmark, d_mark, f_mark, g_mark, h_mark)
  call fch2tm_permute_cart(n6dmark, n10fmark, n15gmark, n21hmark, k, d_mark,&
                           f_mark, g_mark, h_mark, nbf, idx, norm)
 end if
 forall(i=1:nif1, j=1:nbf) coeff(j,i) = coeff0(idx(j),i)*norm(j)
 deallocate(norm)
 deallocate(d_mark, f_mark, g_mark, h_mark, coeff0, idx)
 ! adjustment finished

 if(uhf) then
  allocate(alpha_coeff(nbf,nif), source=coeff(:,1:nif))
  allocate(beta_coeff(nbf,nif), source=coeff(:,nif+1:nif1))
 else
  allocate(alpha_coeff(nbf,nif), source=coeff)
 end if
 deallocate(coeff)

 open(newunit=fid,file='mos',status='replace')
 if(uhf) then
  write(fid,'(A)') '$uhfmo_alpha    scfconv=8   format(4d20.14)'
 else
  write(fid,'(A)') '$scfmo    scfconv=8   format(4d20.14)'
 end if
 write(fid,'(A)') '# generated by fch2tm of MOKIT'
 do i = 1, nif, 1
  write(fid,'(I6,A,D20.14,A,I0)') i,'  a  eigenvalue=',eigen_e_a(i),' nsaos=',&
                                  nbf
  write(fid,'(4D20.14)') alpha_coeff(:,i)
 end do ! for i

 if(uhf) then
  write(fid,'(A)') '$uhfmo_beta    scfconv=8   format(4d20.14)'
  write(fid,'(A)') '# generated by fch2tm of MOKIT'
  do i = 1, nif, 1
   write(fid,'(I6,A,D20.14,A,I0)') i,'  a  eigenvalue=',eigen_e_b(i),' nsaos=',&
                                   nbf
   write(fid,'(4D20.14)') beta_coeff(:,i)
  end do ! for i
 end if

 write(fid,'(A)') '$end'
 close(fid)
 call free_arrays_in_fch_content()
end subroutine fch2tm

